{"ast":null,"code":"import { BufferAttribute as t, BufferGeometry as e, Vector3 as s, Plane as r, Triangle as n, Object3D as o, Mesh as i, SphereGeometry as h, MeshBasicMaterial as c, BoxGeometry as a, LineBasicMaterial as u, Line as l } from \"three\";\nclass d {\n  static roundNumber(t, e) {\n    const s = Math.pow(10, e);\n    return Math.round(t * s) / s;\n  }\n  static sample(t) {\n    return t[Math.floor(Math.random() * t.length)];\n  }\n  static distanceToSquared(t, e) {\n    var s = t.x - e.x,\n      r = t.y - e.y,\n      n = t.z - e.z;\n    return s * s + r * r + n * n;\n  }\n  static isPointInPoly(t, e) {\n    for (var s = !1, r = -1, n = t.length, o = n - 1; ++r < n; o = r) (t[r].z <= e.z && e.z < t[o].z || t[o].z <= e.z && e.z < t[r].z) && e.x < (t[o].x - t[r].x) * (e.z - t[r].z) / (t[o].z - t[r].z) + t[r].x && (s = !s);\n    return s;\n  }\n  static isVectorInPolygon(t, e, s) {\n    var r = 1e5,\n      n = -1e5,\n      o = [];\n    return e.vertexIds.forEach(t => {\n      r = Math.min(s[t].y, r), n = Math.max(s[t].y, n), o.push(s[t]);\n    }), !!(t.y < n + .5 && t.y > r - .5 && this.isPointInPoly(o, t));\n  }\n  static triarea2(t, e, s) {\n    return (s.x - t.x) * (e.z - t.z) - (e.x - t.x) * (s.z - t.z);\n  }\n  static vequal(t, e) {\n    return this.distanceToSquared(t, e) < 1e-5;\n  }\n  static mergeVertices(s) {\n    let r = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e-4;\n    r = Math.max(r, Number.EPSILON);\n    for (var n = {}, o = s.getIndex(), i = s.getAttribute(\"position\"), h = o ? o.count : i.count, c = 0, a = [], u = [], l = Math.log10(1 / r), d = Math.pow(10, l), p = 0; p < h; p++) {\n      var g = o ? o.getX(p) : p,\n        f = \"\";\n      f += ~~(i.getX(g) * d) + \",\", f += ~~(i.getY(g) * d) + \",\", (f += ~~(i.getZ(g) * d) + \",\") in n ? a.push(n[f]) : (u.push(i.getX(g)), u.push(i.getY(g)), u.push(i.getZ(g)), n[f] = c, a.push(c), c++);\n    }\n    const v = new t(new Float32Array(u), i.itemSize, i.normalized),\n      b = new e();\n    return b.setAttribute(\"position\", v), b.setIndex(a), b;\n  }\n}\nclass p {\n  constructor(t) {\n    this.content = [], this.scoreFunction = t;\n  }\n  push(t) {\n    this.content.push(t), this.sinkDown(this.content.length - 1);\n  }\n  pop() {\n    const t = this.content[0],\n      e = this.content.pop();\n    return this.content.length > 0 && (this.content[0] = e, this.bubbleUp(0)), t;\n  }\n  remove(t) {\n    const e = this.content.indexOf(t),\n      s = this.content.pop();\n    e !== this.content.length - 1 && (this.content[e] = s, this.scoreFunction(s) < this.scoreFunction(t) ? this.sinkDown(e) : this.bubbleUp(e));\n  }\n  size() {\n    return this.content.length;\n  }\n  rescoreElement(t) {\n    this.sinkDown(this.content.indexOf(t));\n  }\n  sinkDown(t) {\n    const e = this.content[t];\n    for (; t > 0;) {\n      const s = (t + 1 >> 1) - 1,\n        r = this.content[s];\n      if (!(this.scoreFunction(e) < this.scoreFunction(r))) break;\n      this.content[s] = e, this.content[t] = r, t = s;\n    }\n  }\n  bubbleUp(t) {\n    const e = this.content.length,\n      s = this.content[t],\n      r = this.scoreFunction(s);\n    for (;;) {\n      const n = t + 1 << 1,\n        o = n - 1;\n      let i,\n        h = null;\n      if (o < e && (i = this.scoreFunction(this.content[o]), i < r && (h = o)), n < e && this.scoreFunction(this.content[n]) < (null === h ? r : i) && (h = n), null === h) break;\n      this.content[t] = this.content[h], this.content[h] = s, t = h;\n    }\n  }\n}\nclass g {\n  constructor() {\n    this.portals = [];\n  }\n  push(t, e) {\n    void 0 === e && (e = t), this.portals.push({\n      left: t,\n      right: e\n    });\n  }\n  stringPull() {\n    const t = this.portals,\n      e = [];\n    let s,\n      r,\n      n,\n      o = 0,\n      i = 0,\n      h = 0;\n    s = t[0].left, r = t[0].left, n = t[0].right, e.push(s);\n    for (let c = 1; c < t.length; c++) {\n      const a = t[c].left,\n        u = t[c].right;\n      if (d.triarea2(s, n, u) <= 0) {\n        if (!(d.vequal(s, n) || d.triarea2(s, r, u) > 0)) {\n          e.push(r), s = r, o = i, r = s, n = s, i = o, h = o, c = o;\n          continue;\n        }\n        n = u, h = c;\n      }\n      if (d.triarea2(s, r, a) >= 0) {\n        if (!(d.vequal(s, r) || d.triarea2(s, n, a) < 0)) {\n          e.push(n), s = n, o = h, r = s, n = s, i = o, h = o, c = o;\n          continue;\n        }\n        r = a, i = c;\n      }\n    }\n    return 0 !== e.length && d.vequal(e[e.length - 1], t[t.length - 1].left) || e.push(t[t.length - 1].left), this.path = e, e;\n  }\n}\nclass f {\n  constructor() {\n    this.zones = {};\n  }\n  static createZone(t) {\n    let e = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1e-4;\n    return class {\n      static buildZone(t, e) {\n        const r = this._buildNavigationMesh(t, e),\n          n = {};\n        r.vertices.forEach(t => {\n          t.x = d.roundNumber(t.x, 2), t.y = d.roundNumber(t.y, 2), t.z = d.roundNumber(t.z, 2);\n        }), n.vertices = r.vertices;\n        const o = this._buildPolygonGroups(r);\n        return n.groups = new Array(o.length), o.forEach((t, e) => {\n          const r = new Map();\n          t.forEach((t, e) => {\n            r.set(t, e);\n          });\n          const o = new Array(t.length);\n          t.forEach((t, e) => {\n            const i = [];\n            t.neighbours.forEach(t => i.push(r.get(t)));\n            const h = [];\n            t.neighbours.forEach(e => h.push(this._getSharedVerticesInOrder(t, e)));\n            const c = new s(0, 0, 0);\n            c.add(n.vertices[t.vertexIds[0]]), c.add(n.vertices[t.vertexIds[1]]), c.add(n.vertices[t.vertexIds[2]]), c.divideScalar(3), c.x = d.roundNumber(c.x, 2), c.y = d.roundNumber(c.y, 2), c.z = d.roundNumber(c.z, 2), o[e] = {\n              id: e,\n              neighbours: i,\n              vertexIds: t.vertexIds,\n              centroid: c,\n              portals: h\n            };\n          }), n.groups[e] = o;\n        }), n;\n      }\n      static _buildNavigationMesh(t, e) {\n        return t = d.mergeVertices(t, e), this._buildPolygonsFromGeometry(t);\n      }\n      static _spreadGroupId(t) {\n        let e = new Set([t]);\n        for (; e.size > 0;) {\n          const s = e;\n          e = new Set(), s.forEach(s => {\n            s.group = t.group, s.neighbours.forEach(t => {\n              void 0 === t.group && e.add(t);\n            });\n          });\n        }\n      }\n      static _buildPolygonGroups(t) {\n        const e = [];\n        return t.polygons.forEach(t => {\n          void 0 !== t.group ? e[t.group].push(t) : (t.group = e.length, this._spreadGroupId(t), e.push([t]));\n        }), e;\n      }\n      static _buildPolygonNeighbours(t, e) {\n        const s = new Set(),\n          r = e[t.vertexIds[1]],\n          n = e[t.vertexIds[2]];\n        return e[t.vertexIds[0]].forEach(e => {\n          e !== t && (r.includes(e) || n.includes(e)) && s.add(e);\n        }), r.forEach(e => {\n          e !== t && n.includes(e) && s.add(e);\n        }), s;\n      }\n      static _buildPolygonsFromGeometry(t) {\n        const e = [],\n          r = [],\n          n = t.attributes.position,\n          o = t.index,\n          i = [];\n        for (let t = 0; t < n.count; t++) r.push(new s().fromBufferAttribute(n, t)), i[t] = [];\n        for (let s = 0; s < t.index.count; s += 3) {\n          const t = o.getX(s),\n            r = o.getX(s + 1),\n            n = o.getX(s + 2),\n            h = {\n              vertexIds: [t, r, n],\n              neighbours: null\n            };\n          e.push(h), i[t].push(h), i[r].push(h), i[n].push(h);\n        }\n        return e.forEach(t => {\n          t.neighbours = this._buildPolygonNeighbours(t, i);\n        }), {\n          polygons: e,\n          vertices: r\n        };\n      }\n      static _getSharedVerticesInOrder(t, e) {\n        const s = t.vertexIds,\n          r = s[0],\n          n = s[1],\n          o = s[2],\n          i = e.vertexIds,\n          h = i.includes(r),\n          c = i.includes(n),\n          a = i.includes(o);\n        return h && c && a ? Array.from(s) : h && c ? [r, n] : c && a ? [n, o] : h && a ? [o, r] : (console.warn(\"Error processing navigation mesh neighbors; neighbors with <2 shared vertices found.\"), []);\n      }\n    }.buildZone(t, e);\n  }\n  setZoneData(t, e) {\n    this.zones[t] = e;\n  }\n  getRandomNode(t, e, r, n) {\n    if (!this.zones[t]) return new s();\n    r = r || null, n = n || 0;\n    const o = [];\n    return this.zones[t].groups[e].forEach(t => {\n      r && n ? d.distanceToSquared(r, t.centroid) < n * n && o.push(t.centroid) : o.push(t.centroid);\n    }), d.sample(o) || new s();\n  }\n  getClosestNode(t, e, s) {\n    let r = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : !1;\n    const n = this.zones[e].vertices;\n    let o = null,\n      i = Infinity;\n    return this.zones[e].groups[s].forEach(e => {\n      const s = d.distanceToSquared(e.centroid, t);\n      s < i && (!r || d.isVectorInPolygon(t, e, n)) && (o = e, i = s);\n    }), o;\n  }\n  findPath(t, e, r, n) {\n    const o = this.zones[r].groups[n],\n      i = this.zones[r].vertices,\n      h = this.getClosestNode(t, r, n, !0),\n      c = this.getClosestNode(e, r, n, !0);\n    if (!h || !c) return null;\n    const a = class {\n        static init(t) {\n          for (let e = 0; e < t.length; e++) {\n            const s = t[e];\n            s.f = 0, s.g = 0, s.h = 0, s.cost = 1, s.visited = !1, s.closed = !1, s.parent = null;\n          }\n        }\n        static cleanUp(t) {\n          for (let e = 0; e < t.length; e++) {\n            const s = t[e];\n            delete s.f, delete s.g, delete s.h, delete s.cost, delete s.visited, delete s.closed, delete s.parent;\n          }\n        }\n        static heap() {\n          return new p(function (t) {\n            return t.f;\n          });\n        }\n        static search(t, e, s) {\n          this.init(t);\n          const r = this.heap();\n          for (r.push(e); r.size() > 0;) {\n            const e = r.pop();\n            if (e === s) {\n              let t = e;\n              const s = [];\n              for (; t.parent;) s.push(t), t = t.parent;\n              return this.cleanUp(s), s.reverse();\n            }\n            e.closed = !0;\n            const n = this.neighbours(t, e);\n            for (let t = 0, o = n.length; t < o; t++) {\n              const o = n[t];\n              if (o.closed) continue;\n              const i = e.g + o.cost,\n                h = o.visited;\n              if (!h || i < o.g) {\n                if (o.visited = !0, o.parent = e, !o.centroid || !s.centroid) throw new Error(\"Unexpected state\");\n                o.h = o.h || this.heuristic(o.centroid, s.centroid), o.g = i, o.f = o.g + o.h, h ? r.rescoreElement(o) : r.push(o);\n              }\n            }\n          }\n          return [];\n        }\n        static heuristic(t, e) {\n          return d.distanceToSquared(t, e);\n        }\n        static neighbours(t, e) {\n          const s = [];\n          for (let r = 0; r < e.neighbours.length; r++) s.push(t[e.neighbours[r]]);\n          return s;\n        }\n      }.search(o, h, c),\n      u = function (t, e) {\n        for (var s = 0; s < t.neighbours.length; s++) if (t.neighbours[s] === e.id) return t.portals[s];\n      },\n      l = new g();\n    l.push(t);\n    for (let t = 0; t < a.length; t++) {\n      const e = a[t],\n        s = a[t + 1];\n      if (s) {\n        const t = u(e, s);\n        l.push(i[t[0]], i[t[1]]);\n      }\n    }\n    l.push(e), l.stringPull();\n    const f = l.path.map(t => new s(t.x, t.y, t.z));\n    return f.shift(), f;\n  }\n}\nf.prototype.getGroup = function () {\n  const t = new r();\n  return function (e, s) {\n    let r = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : !1;\n    if (!this.zones[e]) return null;\n    let n = null,\n      o = Math.pow(50, 2);\n    const i = this.zones[e];\n    for (let e = 0; e < i.groups.length; e++) {\n      const h = i.groups[e];\n      for (const c of h) {\n        if (r && (t.setFromCoplanarPoints(i.vertices[c.vertexIds[0]], i.vertices[c.vertexIds[1]], i.vertices[c.vertexIds[2]]), Math.abs(t.distanceToPoint(s)) < .01) && d.isPointInPoly([i.vertices[c.vertexIds[0]], i.vertices[c.vertexIds[1]], i.vertices[c.vertexIds[2]]], s)) return e;\n        const h = d.distanceToSquared(c.centroid, s);\n        h < o && (n = e, o = h);\n      }\n    }\n    return n;\n  };\n}(), f.prototype.clampStep = function () {\n  const t = new s(),\n    e = new r(),\n    o = new n(),\n    i = new s();\n  let h,\n    c,\n    a = new s();\n  return function (s, r, n, u, l, d) {\n    const p = this.zones[u].vertices,\n      g = this.zones[u].groups[l],\n      f = [n],\n      v = {};\n    v[n.id] = 0, h = void 0, a.set(0, 0, 0), c = Infinity, e.setFromCoplanarPoints(p[n.vertexIds[0]], p[n.vertexIds[1]], p[n.vertexIds[2]]), e.projectPoint(r, t), i.copy(t);\n    for (let e = f.pop(); e; e = f.pop()) {\n      o.set(p[e.vertexIds[0]], p[e.vertexIds[1]], p[e.vertexIds[2]]), o.closestPointToPoint(i, t), t.distanceToSquared(i) < c && (h = e, a.copy(t), c = t.distanceToSquared(i));\n      const s = v[e.id];\n      if (!(s > 2)) for (let t = 0; t < e.neighbours.length; t++) {\n        const r = g[e.neighbours[t]];\n        r.id in v || (f.push(r), v[r.id] = s + 1);\n      }\n    }\n    return d.copy(a), h;\n  };\n}();\nclass v extends o {\n  constructor() {\n    super(), this._playerMarker = new i(new h(.25, 32, 32), new c({\n      color: 15631215\n    })), this._targetMarker = new i(new a(.3, .3, .3), new c({\n      color: 14469912\n    })), this._nodeMarker = new i(new a(.1, .8, .1), new c({\n      color: 4417387\n    })), this._stepMarker = new i(new a(.1, 1, .1), new c({\n      color: 14472114\n    })), this._pathMarker = new o(), this._pathLineMaterial = new u({\n      color: 41903,\n      linewidth: 2\n    }), this._pathPointMaterial = new c({\n      color: 41903\n    }), this._pathPointGeometry = new h(.08), this._markers = [this._playerMarker, this._targetMarker, this._nodeMarker, this._stepMarker, this._pathMarker], this._markers.forEach(t => {\n      t.visible = !1, this.add(t);\n    });\n  }\n  setPath(s) {\n    for (; this._pathMarker.children.length;) this._pathMarker.children[0].visible = !1, this._pathMarker.remove(this._pathMarker.children[0]);\n    s = [this._playerMarker.position].concat(s);\n    const r = new e();\n    r.setAttribute(\"position\", new t(new Float32Array(3 * s.length), 3));\n    for (let t = 0; t < s.length; t++) r.attributes.position.setXYZ(t, s[t].x, s[t].y + .2, s[t].z);\n    this._pathMarker.add(new l(r, this._pathLineMaterial));\n    for (let t = 0; t < s.length - 1; t++) {\n      const e = new i(this._pathPointGeometry, this._pathPointMaterial);\n      e.position.copy(s[t]), e.position.y += .2, this._pathMarker.add(e);\n    }\n    return this._pathMarker.visible = !0, this;\n  }\n  setPlayerPosition(t) {\n    return this._playerMarker.position.copy(t), this._playerMarker.visible = !0, this;\n  }\n  setTargetPosition(t) {\n    return this._targetMarker.position.copy(t), this._targetMarker.visible = !0, this;\n  }\n  setNodePosition(t) {\n    return this._nodeMarker.position.copy(t), this._nodeMarker.visible = !0, this;\n  }\n  setStepPosition(t) {\n    return this._stepMarker.position.copy(t), this._stepMarker.visible = !0, this;\n  }\n  reset() {\n    for (; this._pathMarker.children.length;) this._pathMarker.children[0].visible = !1, this._pathMarker.remove(this._pathMarker.children[0]);\n    return this._markers.forEach(t => {\n      t.visible = !1;\n    }), this;\n  }\n}\nexport { f as Pathfinding, v as PathfindingHelper };","map":{"version":3,"names":["d","roundNumber","t","e","s","Math","pow","round","sample","floor","random","length","distanceToSquared","x","r","y","n","z","isPointInPoly","o","isVectorInPolygon","vertexIds","forEach","min","max","push","triarea2","vequal","mergeVertices","arguments","undefined","Number","EPSILON","getIndex","i","getAttribute","h","count","c","a","u","l","log10","p","g","getX","f","getY","getZ","v","Float32Array","itemSize","normalized","b","setAttribute","setIndex","constructor","content","scoreFunction","sinkDown","pop","bubbleUp","remove","indexOf","size","rescoreElement","portals","left","right","stringPull","path","zones","createZone","buildZone","_buildNavigationMesh","vertices","_buildPolygonGroups","groups","Array","Map","set","neighbours","get","_getSharedVerticesInOrder","add","divideScalar","id","centroid","_buildPolygonsFromGeometry","_spreadGroupId","Set","group","polygons","_buildPolygonNeighbours","includes","attributes","position","index","fromBufferAttribute","from","console","warn","setZoneData","getRandomNode","getClosestNode","Infinity","findPath","init","cost","visited","closed","parent","cleanUp","heap","search","reverse","Error","heuristic","getPortalFromTo","map","shift","prototype","getGroup","setFromCoplanarPoints","abs","distanceToPoint","clampStep","projectPoint","copy","closestPointToPoint","_playerMarker","color","_targetMarker","_nodeMarker","_stepMarker","_pathMarker","_pathLineMaterial","linewidth","_pathPointMaterial","_pathPointGeometry","_markers","visible","setPath","children","concat","setXYZ","setPlayerPosition","setTargetPosition","setNodePosition","setStepPosition","reset","Pathfinding","PathfindingHelper"],"sources":["/Users/dimitrischatzopoulos/Desktop/dais/node_modules/three-pathfinding/src/Utils.js","/Users/dimitrischatzopoulos/Desktop/dais/node_modules/three-pathfinding/src/BinaryHeap.js","/Users/dimitrischatzopoulos/Desktop/dais/node_modules/three-pathfinding/src/Channel.js","/Users/dimitrischatzopoulos/Desktop/dais/node_modules/three-pathfinding/src/Pathfinding.js","/Users/dimitrischatzopoulos/Desktop/dais/node_modules/three-pathfinding/src/Builder.js","/Users/dimitrischatzopoulos/Desktop/dais/node_modules/three-pathfinding/src/AStar.js","/Users/dimitrischatzopoulos/Desktop/dais/node_modules/three-pathfinding/src/PathfindingHelper.js"],"sourcesContent":["import { BufferAttribute, BufferGeometry } from 'three';\n\nclass Utils {\n\n  static roundNumber (value, decimals) {\n    const factor = Math.pow(10, decimals);\n    return Math.round(value * factor) / factor;\n  }\n\n  static sample (list) {\n    return list[Math.floor(Math.random() * list.length)];\n  }\n\n  static distanceToSquared (a, b) {\n\n    var dx = a.x - b.x;\n    var dy = a.y - b.y;\n    var dz = a.z - b.z;\n\n    return dx * dx + dy * dy + dz * dz;\n\n  }\n\n  //+ Jonas Raoni Soares Silva\n  //@ http://jsfromhell.com/math/is-point-in-poly [rev. #0]\n  static isPointInPoly (poly, pt) {\n    for (var c = false, i = -1, l = poly.length, j = l - 1; ++i < l; j = i)\n      ((poly[i].z <= pt.z && pt.z < poly[j].z) || (poly[j].z <= pt.z && pt.z < poly[i].z)) && (pt.x < (poly[j].x - poly[i].x) * (pt.z - poly[i].z) / (poly[j].z - poly[i].z) + poly[i].x) && (c = !c);\n    return c;\n  }\n\n  static isVectorInPolygon (vector, polygon, vertices) {\n\n    // reference point will be the centroid of the polygon\n    // We need to rotate the vector as well as all the points which the polygon uses\n\n    var lowestPoint = 100000;\n    var highestPoint = -100000;\n\n    var polygonVertices = [];\n\n    polygon.vertexIds.forEach((vId) => {\n      lowestPoint = Math.min(vertices[vId].y, lowestPoint);\n      highestPoint = Math.max(vertices[vId].y, highestPoint);\n      polygonVertices.push(vertices[vId]);\n    });\n\n    if (vector.y < highestPoint + 0.5 && vector.y > lowestPoint - 0.5 &&\n      this.isPointInPoly(polygonVertices, vector)) {\n      return true;\n    }\n    return false;\n  }\n\n  static triarea2 (a, b, c) {\n    var ax = b.x - a.x;\n    var az = b.z - a.z;\n    var bx = c.x - a.x;\n    var bz = c.z - a.z;\n    return bx * az - ax * bz;\n  }\n\n  static vequal (a, b) {\n    return this.distanceToSquared(a, b) < 0.00001;\n  }\n\n  /**\n   * Modified version of BufferGeometryUtils.mergeVertices, ignoring vertex\n   * attributes other than position.\n   *\n   * @param {THREE.BufferGeometry} geometry\n   * @param {number} tolerance\n   * @return {THREE.BufferGeometry>}\n   */\n  static mergeVertices (geometry, tolerance = 1e-4) {\n\n    tolerance = Math.max( tolerance, Number.EPSILON );\n\n    // Generate an index buffer if the geometry doesn't have one, or optimize it\n    // if it's already available.\n    var hashToIndex = {};\n    var indices = geometry.getIndex();\n    var positions = geometry.getAttribute( 'position' );\n    var vertexCount = indices ? indices.count : positions.count;\n\n    // Next value for triangle indices.\n    var nextIndex = 0;\n\n    var newIndices = [];\n    var newPositions = [];\n\n    // Convert the error tolerance to an amount of decimal places to truncate to.\n    var decimalShift = Math.log10( 1 / tolerance );\n    var shiftMultiplier = Math.pow( 10, decimalShift );\n\n    for ( var i = 0; i < vertexCount; i ++ ) {\n\n      var index = indices ? indices.getX( i ) : i;\n\n      // Generate a hash for the vertex attributes at the current index 'i'.\n      var hash = '';\n\n      // Double tilde truncates the decimal value.\n      hash += `${ ~ ~ ( positions.getX( index ) * shiftMultiplier ) },`;\n      hash += `${ ~ ~ ( positions.getY( index ) * shiftMultiplier ) },`;\n      hash += `${ ~ ~ ( positions.getZ( index ) * shiftMultiplier ) },`;\n\n      // Add another reference to the vertex if it's already\n      // used by another index.\n      if ( hash in hashToIndex ) {\n\n        newIndices.push( hashToIndex[ hash ] );\n\n      } else {\n\n        newPositions.push( positions.getX( index ) );\n        newPositions.push( positions.getY( index ) );\n        newPositions.push( positions.getZ( index ) );\n\n        hashToIndex[ hash ] = nextIndex;\n        newIndices.push( nextIndex );\n        nextIndex ++;\n\n      }\n\n    }\n\n    // Construct merged BufferGeometry.\n\n    const positionAttribute = new BufferAttribute(\n      new Float32Array( newPositions ),\n      positions.itemSize,\n      positions.normalized\n    );\n\n    const result = new BufferGeometry();\n    result.setAttribute( 'position', positionAttribute );\n    result.setIndex( newIndices );\n\n    return result;\n\n  }\n}\n\nexport { Utils };\n","// javascript-astar\n// http://github.com/bgrins/javascript-astar\n// Freely distributable under the MIT License.\n// Implements the astar search algorithm in javascript using a binary heap.\n\nclass BinaryHeap {\n  constructor (scoreFunction) {\n    this.content = [];\n    this.scoreFunction = scoreFunction;\n  }\n\n  push (element) {\n    // Add the new element to the end of the array.\n    this.content.push(element);\n\n    // Allow it to sink down.\n    this.sinkDown(this.content.length - 1);\n  }\n\n  pop () {\n    // Store the first element so we can return it later.\n    const result = this.content[0];\n    // Get the element at the end of the array.\n    const end = this.content.pop();\n    // If there are any elements left, put the end element at the\n    // start, and let it bubble up.\n    if (this.content.length > 0) {\n      this.content[0] = end;\n      this.bubbleUp(0);\n    }\n    return result;\n  }\n\n  remove (node) {\n    const i = this.content.indexOf(node);\n\n    // When it is found, the process seen in 'pop' is repeated\n    // to fill up the hole.\n    const end = this.content.pop();\n\n    if (i !== this.content.length - 1) {\n      this.content[i] = end;\n\n      if (this.scoreFunction(end) < this.scoreFunction(node)) {\n        this.sinkDown(i);\n      } else {\n        this.bubbleUp(i);\n      }\n    }\n  }\n\n  size () {\n    return this.content.length;\n  }\n\n  rescoreElement (node) {\n    this.sinkDown(this.content.indexOf(node));\n  }\n\n  sinkDown (n) {\n    // Fetch the element that has to be sunk.\n    const element = this.content[n];\n\n    // When at 0, an element can not sink any further.\n    while (n > 0) {\n      // Compute the parent element's index, and fetch it.\n      const parentN = ((n + 1) >> 1) - 1;\n      const parent = this.content[parentN];\n\n      if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n        // Swap the elements if the parent is greater.\n        this.content[parentN] = element;\n        this.content[n] = parent;\n        // Update 'n' to continue at the new position.\n        n = parentN;\n      } else {\n        // Found a parent that is less, no need to sink any further.\n        break;\n      }\n    }\n  }\n\n  bubbleUp (n) {\n    // Look up the target element and its score.\n    const length = this.content.length,\n      element = this.content[n],\n      elemScore = this.scoreFunction(element);\n\n    while (true) {\n      // Compute the indices of the child elements.\n      const child2N = (n + 1) << 1,\n        child1N = child2N - 1;\n      // This is used to store the new position of the element,\n      // if any.\n      let swap = null;\n      let child1Score;\n      // If the first child exists (is inside the array)...\n      if (child1N < length) {\n        // Look it up and compute its score.\n        const child1 = this.content[child1N];\n        child1Score = this.scoreFunction(child1);\n\n        // If the score is less than our element's, we need to swap.\n        if (child1Score < elemScore) {\n          swap = child1N;\n        }\n      }\n\n      // Do the same checks for the other child.\n      if (child2N < length) {\n        const child2 = this.content[child2N],\n          child2Score = this.scoreFunction(child2);\n        if (child2Score < (swap === null ? elemScore : child1Score)) {\n          swap = child2N;\n        }\n      }\n\n      // If the element needs to be moved, swap it, and continue.\n      if (swap !== null) {\n        this.content[n] = this.content[swap];\n        this.content[swap] = element;\n        n = swap;\n      }\n\n      // Otherwise, we are done.\n      else {\n        break;\n      }\n    }\n  }\n\n}\n\nexport { BinaryHeap };\n","import { Utils } from './Utils';\n\nclass Channel {\n  constructor () {\n    this.portals = [];\n  }\n\n  push (p1, p2) {\n    if (p2 === undefined) p2 = p1;\n    this.portals.push({\n      left: p1,\n      right: p2\n    });\n  }\n\n  stringPull () {\n    const portals = this.portals;\n    const pts = [];\n    // Init scan state\n    let portalApex, portalLeft, portalRight;\n    let apexIndex = 0,\n      leftIndex = 0,\n      rightIndex = 0;\n\n    portalApex = portals[0].left;\n    portalLeft = portals[0].left;\n    portalRight = portals[0].right;\n\n    // Add start point.\n    pts.push(portalApex);\n\n    for (let i = 1; i < portals.length; i++) {\n      const left = portals[i].left;\n      const right = portals[i].right;\n\n      // Update right vertex.\n      if (Utils.triarea2(portalApex, portalRight, right) <= 0.0) {\n        if (Utils.vequal(portalApex, portalRight) || Utils.triarea2(portalApex, portalLeft, right) > 0.0) {\n          // Tighten the funnel.\n          portalRight = right;\n          rightIndex = i;\n        } else {\n          // Right over left, insert left to path and restart scan from portal left point.\n          pts.push(portalLeft);\n          // Make current left the new apex.\n          portalApex = portalLeft;\n          apexIndex = leftIndex;\n          // Reset portal\n          portalLeft = portalApex;\n          portalRight = portalApex;\n          leftIndex = apexIndex;\n          rightIndex = apexIndex;\n          // Restart scan\n          i = apexIndex;\n          continue;\n        }\n      }\n\n      // Update left vertex.\n      if (Utils.triarea2(portalApex, portalLeft, left) >= 0.0) {\n        if (Utils.vequal(portalApex, portalLeft) || Utils.triarea2(portalApex, portalRight, left) < 0.0) {\n          // Tighten the funnel.\n          portalLeft = left;\n          leftIndex = i;\n        } else {\n          // Left over right, insert right to path and restart scan from portal right point.\n          pts.push(portalRight);\n          // Make current right the new apex.\n          portalApex = portalRight;\n          apexIndex = rightIndex;\n          // Reset portal\n          portalLeft = portalApex;\n          portalRight = portalApex;\n          leftIndex = apexIndex;\n          rightIndex = apexIndex;\n          // Restart scan\n          i = apexIndex;\n          continue;\n        }\n      }\n    }\n\n    if ((pts.length === 0) || (!Utils.vequal(pts[pts.length - 1], portals[portals.length - 1].left))) {\n      // Append last point to path.\n      pts.push(portals[portals.length - 1].left);\n    }\n\n    this.path = pts;\n    return pts;\n  }\n}\n\nexport { Channel };\n","import {\n\tVector3,\n\tPlane,\n\tTriangle,\n} from 'three';\n\nimport { Utils } from './Utils';\nimport { AStar } from './AStar';\nimport { Builder } from './Builder';\nimport { Channel } from './Channel';\n\n/**\n * Defines an instance of the pathfinding module, with one or more zones.\n */\nclass Pathfinding {\n\tconstructor () {\n\t\tthis.zones = {};\n\t}\n\n\t/**\n\t * (Static) Builds a zone/node set from navigation mesh geometry.\n\t * @param  {BufferGeometry} geometry\n\t * @param  {number} tolerance Vertex welding tolerance.\n\t * @return {Zone}\n\t */\n\tstatic createZone (geometry, tolerance = 1e-4) {\n\t\treturn Builder.buildZone(geometry, tolerance);\n\t}\n\n\t/**\n\t * Sets data for the given zone.\n\t * @param {string} zoneID\n\t * @param {Zone} zone\n\t */\n\tsetZoneData (zoneID, zone) {\n\t\tthis.zones[zoneID] = zone;\n\t}\n\n\t/**\n\t * Returns a random node within a given range of a given position.\n\t * @param  {string} zoneID\n\t * @param  {number} groupID\n\t * @param  {Vector3} nearPosition\n\t * @param  {number} nearRange\n\t * @return {Node}\n\t */\n\tgetRandomNode (zoneID, groupID, nearPosition, nearRange) {\n\n\t\tif (!this.zones[zoneID]) return new Vector3();\n\n\t\tnearPosition = nearPosition || null;\n\t\tnearRange = nearRange || 0;\n\n\t\tconst candidates = [];\n\t\tconst polygons = this.zones[zoneID].groups[groupID];\n\n\t\tpolygons.forEach((p) => {\n\t\t\tif (nearPosition && nearRange) {\n\t\t\t\tif (Utils.distanceToSquared(nearPosition, p.centroid) < nearRange * nearRange) {\n\t\t\t\t\tcandidates.push(p.centroid);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcandidates.push(p.centroid);\n\t\t\t}\n\t\t});\n\n\t\treturn Utils.sample(candidates) || new Vector3();\n\t}\n\n\t/**\n\t * Returns the closest node to the target position.\n\t * @param  {Vector3} position\n\t * @param  {string}  zoneID\n\t * @param  {number}  groupID\n\t * @param  {boolean} checkPolygon\n\t * @return {Node}\n\t */\n\tgetClosestNode (position, zoneID, groupID, checkPolygon = false) {\n\t\tconst nodes = this.zones[zoneID].groups[groupID];\n\t\tconst vertices = this.zones[zoneID].vertices;\n\t\tlet closestNode = null;\n\t\tlet closestDistance = Infinity;\n\n\t\tnodes.forEach((node) => {\n\t\t\tconst distance = Utils.distanceToSquared(node.centroid, position);\n\t\t\tif (distance < closestDistance\n\t\t\t\t\t&& (!checkPolygon || Utils.isVectorInPolygon(position, node, vertices))) {\n\t\t\t\tclosestNode = node;\n\t\t\t\tclosestDistance = distance;\n\t\t\t}\n\t\t});\n\n\t\treturn closestNode;\n\t}\n\n\t/**\n\t * Returns a path between given start and end points. If a complete path\n\t * cannot be found, will return the nearest endpoint available.\n\t *\n\t * @param  {Vector3} startPosition Start position.\n\t * @param  {Vector3} targetPosition Destination.\n\t * @param  {string} zoneID ID of current zone.\n\t * @param  {number} groupID Current group ID.\n\t * @return {Array<Vector3>} Array of points defining the path.\n\t */\n\tfindPath (startPosition, targetPosition, zoneID, groupID) {\n\t\tconst nodes = this.zones[zoneID].groups[groupID];\n\t\tconst vertices = this.zones[zoneID].vertices;\n\n\t\tconst closestNode = this.getClosestNode(startPosition, zoneID, groupID, true);\n\t\tconst farthestNode = this.getClosestNode(targetPosition, zoneID, groupID, true);\n\n\t\t// If we can't find any node, just go straight to the target\n\t\tif (!closestNode || !farthestNode) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst paths = AStar.search(nodes, closestNode, farthestNode);\n\n\t\tconst getPortalFromTo = function (a, b) {\n\t\t\tfor (var i = 0; i < a.neighbours.length; i++) {\n\t\t\t\tif (a.neighbours[i] === b.id) {\n\t\t\t\t\treturn a.portals[i];\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\t// We have the corridor, now pull the rope.\n\t\tconst channel = new Channel();\n\t\tchannel.push(startPosition);\n\t\tfor (let i = 0; i < paths.length; i++) {\n\t\t\tconst polygon = paths[i];\n\t\t\tconst nextPolygon = paths[i + 1];\n\n\t\t\tif (nextPolygon) {\n\t\t\t\tconst portals = getPortalFromTo(polygon, nextPolygon);\n\t\t\t\tchannel.push(\n\t\t\t\t\tvertices[portals[0]],\n\t\t\t\t\tvertices[portals[1]]\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t\tchannel.push(targetPosition);\n\t\tchannel.stringPull();\n\n\t\t// Return the path, omitting first position (which is already known).\n\t\tconst path = channel.path.map((c) => new Vector3(c.x, c.y, c.z));\n\t\tpath.shift();\n\t\treturn path;\n\t}\n}\n\n/**\n * Returns closest node group ID for given position.\n * @param  {string} zoneID\n * @param  {Vector3} position\n * @return {number}\n */\nPathfinding.prototype.getGroup = (function() {\n\tconst plane = new Plane();\n\treturn function (zoneID, position, checkPolygon = false) {\n\t\tif (!this.zones[zoneID]) return null;\n\n\t\tlet closestNodeGroup = null;\n\t\tlet distance = Math.pow(50, 2);\n\t\tconst zone = this.zones[zoneID];\n\n\t\tfor (let i = 0; i < zone.groups.length; i++) {\n\t\t\tconst group = zone.groups[i];\n\t\t\tfor (const node of group) {\n\t\t\t\tif (checkPolygon) {\n\t\t\t\t\tplane.setFromCoplanarPoints(\n\t\t\t\t\t\tzone.vertices[node.vertexIds[0]],\n\t\t\t\t\t\tzone.vertices[node.vertexIds[1]],\n\t\t\t\t\t\tzone.vertices[node.vertexIds[2]]\n\t\t\t\t\t);\n\t\t\t\t\tif (Math.abs(plane.distanceToPoint(position)) < 0.01) {\n\t\t\t\t\t\tconst poly = [\n\t\t\t\t\t\t\tzone.vertices[node.vertexIds[0]],\n\t\t\t\t\t\t\tzone.vertices[node.vertexIds[1]],\n\t\t\t\t\t\t\tzone.vertices[node.vertexIds[2]]\n\t\t\t\t\t\t];\n\t\t\t\t\t\tif(Utils.isPointInPoly(poly, position)) {\n\t\t\t\t\t\t\treturn i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tconst measuredDistance = Utils.distanceToSquared(node.centroid, position);\n\t\t\t\tif (measuredDistance < distance) {\n\t\t\t\t\tclosestNodeGroup = i;\n\t\t\t\t\tdistance = measuredDistance;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn closestNodeGroup;\n\t};\n}());\n\n/**\n * Clamps a step along the navmesh, given start and desired endpoint. May be\n * used to constrain first-person / WASD controls.\n *\n * @param  {Vector3} start\n * @param  {Vector3} end Desired endpoint.\n * @param  {Node} node\n * @param  {string} zoneID\n * @param  {number} groupID\n * @param  {Vector3} endTarget Updated endpoint.\n * @return {Node} Updated node.\n */\nPathfinding.prototype.clampStep = (function () {\n\tconst point = new Vector3();\n\tconst plane = new Plane();\n\tconst triangle = new Triangle();\n\n\tconst endPoint = new Vector3();\n\n\tlet closestNode;\n\tlet closestPoint = new Vector3();\n\tlet closestDistance;\n\n\treturn function (startRef, endRef, node, zoneID, groupID, endTarget) {\n\t\tconst vertices = this.zones[zoneID].vertices;\n\t\tconst nodes = this.zones[zoneID].groups[groupID];\n\n\t\tconst nodeQueue = [node];\n\t\tconst nodeDepth = {};\n\t\tnodeDepth[node.id] = 0;\n\n\t\tclosestNode = undefined;\n\t\tclosestPoint.set(0, 0, 0);\n\t\tclosestDistance = Infinity;\n\n\t\t// Project the step along the current node.\n\t\tplane.setFromCoplanarPoints(\n\t\t\tvertices[node.vertexIds[0]],\n\t\t\tvertices[node.vertexIds[1]],\n\t\t\tvertices[node.vertexIds[2]]\n\t\t);\n\t\tplane.projectPoint(endRef, point);\n\t\tendPoint.copy(point);\n\n\t\tfor (let currentNode = nodeQueue.pop(); currentNode; currentNode = nodeQueue.pop()) {\n\n\t\t\ttriangle.set(\n\t\t\t\tvertices[currentNode.vertexIds[0]],\n\t\t\t\tvertices[currentNode.vertexIds[1]],\n\t\t\t\tvertices[currentNode.vertexIds[2]]\n\t\t\t);\n\n\t\t\ttriangle.closestPointToPoint(endPoint, point);\n\n\t\t\tif (point.distanceToSquared(endPoint) < closestDistance) {\n\t\t\t\tclosestNode = currentNode;\n\t\t\t\tclosestPoint.copy(point);\n\t\t\t\tclosestDistance = point.distanceToSquared(endPoint);\n\t\t\t}\n\n\t\t\tconst depth = nodeDepth[currentNode.id];\n\t\t\tif (depth > 2) continue;\n\n\t\t\tfor (let i = 0; i < currentNode.neighbours.length; i++) {\n\t\t\t\tconst neighbour = nodes[currentNode.neighbours[i]];\n\t\t\t\tif (neighbour.id in nodeDepth) continue;\n\n\t\t\t\tnodeQueue.push(neighbour);\n\t\t\t\tnodeDepth[neighbour.id] = depth + 1;\n\t\t\t}\n\t\t}\n\n\t\tendTarget.copy(closestPoint);\n\t\treturn closestNode;\n\t};\n}());\n\n/**\n * Defines a zone of interconnected groups on a navigation mesh.\n *\n * @type {Object}\n * @property {Array<Group>} groups\n * @property {Array<Vector3>} vertices\n */\nconst Zone = {}; // jshint ignore:line\n\n/**\n * Defines a group within a navigation mesh.\n *\n * @type {Object}\n */\nconst Group = {}; // jshint ignore:line\n\n/**\n * Defines a node (or polygon) within a group.\n *\n * @type {Object}\n * @property {number} id\n * @property {Array<number>} neighbours IDs of neighboring nodes.\n * @property {Array<number>} vertexIds\n * @property {Vector3} centroid\n * @property {Array<Array<number>>} portals Array of portals, each defined by two vertex IDs.\n * @property {boolean} closed\n * @property {number} cost\n */\nconst Node = {}; // jshint ignore:line\n\nexport { Pathfinding };\n","import { Vector3 } from 'three';\n\nimport { Utils } from './Utils';\n\nclass Builder {\n  /**\n   * Constructs groups from the given navigation mesh.\n   * @param  {BufferGeometry} geometry\n   * @param  {number} tolerance\n   * @return {Zone}\n   */\n  static buildZone (geometry, tolerance) {\n\n    const navMesh = this._buildNavigationMesh(geometry, tolerance);\n\n    const zone = {};\n\n    navMesh.vertices.forEach((v) => {\n      v.x = Utils.roundNumber(v.x, 2);\n      v.y = Utils.roundNumber(v.y, 2);\n      v.z = Utils.roundNumber(v.z, 2);\n    });\n\n    zone.vertices = navMesh.vertices;\n\n    const groups = this._buildPolygonGroups(navMesh);\n\n    // TODO: This block represents a large portion of navigation mesh construction time\n    // and could probably be optimized. For example, construct portals while\n    // determining the neighbor graph.\n    zone.groups = new Array(groups.length);\n    groups.forEach((group, groupIndex) => {\n\n      const indexByPolygon = new Map(); // { polygon: index in group }\n      group.forEach((poly, polyIndex) => { indexByPolygon.set(poly, polyIndex); });\n\n      const newGroup = new Array(group.length);\n      group.forEach((poly, polyIndex) => {\n\n        const neighbourIndices = [];\n        poly.neighbours.forEach((n) => neighbourIndices.push(indexByPolygon.get(n)));\n\n        // Build a portal list to each neighbour\n        const portals = [];\n        poly.neighbours.forEach((n) => portals.push(this._getSharedVerticesInOrder(poly, n)));\n\n        const centroid = new Vector3( 0, 0, 0 );\n        centroid.add( zone.vertices[ poly.vertexIds[0] ] );\n        centroid.add( zone.vertices[ poly.vertexIds[1] ] );\n        centroid.add( zone.vertices[ poly.vertexIds[2] ] );\n        centroid.divideScalar( 3 );\n        centroid.x = Utils.roundNumber(centroid.x, 2);\n        centroid.y = Utils.roundNumber(centroid.y, 2);\n        centroid.z = Utils.roundNumber(centroid.z, 2);\n\n        newGroup[polyIndex] = {\n          id: polyIndex,\n          neighbours: neighbourIndices,\n          vertexIds: poly.vertexIds,\n          centroid: centroid,\n          portals: portals\n        };\n      });\n\n      zone.groups[groupIndex] = newGroup;\n    });\n\n    return zone;\n  }\n\n  /**\n   * Constructs a navigation mesh from the given geometry.\n   * @param {BufferGeometry} geometry\n   * @return {Object}\n   */\n  static _buildNavigationMesh (geometry, tolerance) {\n    geometry = Utils.mergeVertices(geometry, tolerance);\n    return this._buildPolygonsFromGeometry(geometry);\n  }\n\n  /**\n   * Spreads the group ID of the given polygon to all connected polygons\n   * @param {Object} seed\n   */\n  static _spreadGroupId (seed) {\n    let nextBatch = new Set([seed]);\n\n    while(nextBatch.size > 0) {\n      const batch = nextBatch;\n      nextBatch = new Set();\n\n      batch.forEach((polygon) => {\n        polygon.group = seed.group;\n        polygon.neighbours.forEach((neighbour) => {\n          if(neighbour.group === undefined) {\n            nextBatch.add(neighbour);\n          }\n        });\n      });\n    }\n  }\n\n  static _buildPolygonGroups (navigationMesh) {\n\n    const polygons = navigationMesh.polygons;\n\n    const polygonGroups = [];\n\n    polygons.forEach((polygon) => {\n      if (polygon.group !== undefined) {\n        // this polygon is already part of a group\n        polygonGroups[polygon.group].push(polygon);\n      } else {\n        // we need to make a new group and spread its ID to neighbors\n        polygon.group = polygonGroups.length;\n        this._spreadGroupId(polygon);\n        polygonGroups.push([polygon]);\n      }\n    });\n\n    return polygonGroups;\n  }\n\n  static _buildPolygonNeighbours (polygon, vertexPolygonMap) {\n    const neighbours = new Set();\n\n    const groupA = vertexPolygonMap[polygon.vertexIds[0]];\n    const groupB = vertexPolygonMap[polygon.vertexIds[1]];\n    const groupC = vertexPolygonMap[polygon.vertexIds[2]];\n\n    // It's only necessary to iterate groups A and B. Polygons contained only\n    // in group C cannot share a >1 vertex with this polygon.\n    // IMPORTANT: Bublé cannot compile for-of loops.\n    groupA.forEach((candidate) => {\n      if (candidate === polygon) return;\n      if (groupB.includes(candidate) || groupC.includes(candidate)) {\n        neighbours.add(candidate);\n      }\n    });\n    groupB.forEach((candidate) => {\n      if (candidate === polygon) return;\n      if (groupC.includes(candidate)) {\n        neighbours.add(candidate);\n      }\n    });\n\n    return neighbours;\n  }\n\n  static _buildPolygonsFromGeometry (geometry) {\n\n    const polygons = [];\n    const vertices = [];\n\n    const position = geometry.attributes.position;\n    const index = geometry.index;\n\n    // Constructing the neighbor graph brute force is O(n²). To avoid that,\n    // create a map from vertices to the polygons that contain them, and use it\n    // while connecting polygons. This reduces complexity to O(n*m), where 'm'\n    // is related to connectivity of the mesh.\n\n    /** Array of polygon objects by vertex index. */\n    const vertexPolygonMap = [];\n\n    for (let i = 0; i < position.count; i++) {\n      vertices.push(new Vector3().fromBufferAttribute(position, i));\n      vertexPolygonMap[i] = [];\n    }\n\n    // Convert the faces into a custom format that supports more than 3 vertices\n    for (let i = 0; i < geometry.index.count; i += 3) {\n      const a = index.getX(i);\n      const b = index.getX(i + 1);\n      const c = index.getX(i + 2);\n      const poly = {vertexIds: [a, b, c], neighbours: null};\n      polygons.push(poly);\n      vertexPolygonMap[a].push(poly);\n      vertexPolygonMap[b].push(poly);\n      vertexPolygonMap[c].push(poly);\n    }\n\n    // Build a list of adjacent polygons\n    polygons.forEach((polygon) => {\n      polygon.neighbours = this._buildPolygonNeighbours(polygon, vertexPolygonMap);\n    });\n\n    return {\n      polygons: polygons,\n      vertices: vertices\n    };\n  }\n\n  static _getSharedVerticesInOrder (a, b) {\n\n    const aList = a.vertexIds;\n    const a0 = aList[0], a1 = aList[1], a2 = aList[2];\n\n    const bList = b.vertexIds;\n    const shared0 = bList.includes(a0);\n    const shared1 = bList.includes(a1);\n    const shared2 = bList.includes(a2);\n\n    // it seems that we shouldn't have an a and b with <2 shared vertices here unless there's a bug\n    // in the neighbor identification code, or perhaps a malformed input geometry; 3 shared vertices\n    // is a kind of embarrassing but possible geometry we should handle\n    if (shared0 && shared1 && shared2) {\n      return Array.from(aList);\n    } else if (shared0 && shared1) {\n      return [a0, a1];\n    } else if (shared1 && shared2) {\n      return [a1, a2];\n    } else if (shared0 && shared2) {\n      return [a2, a0]; // this ordering will affect the string pull algorithm later, not clear if significant\n    } else {\n      console.warn(\"Error processing navigation mesh neighbors; neighbors with <2 shared vertices found.\");\n      return [];\n    }\n  }\n}\n\nexport { Builder };\n","import { BinaryHeap } from './BinaryHeap';\nimport { Utils } from './Utils.js';\n\nclass AStar {\n  static init (graph) {\n    for (let x = 0; x < graph.length; x++) {\n      //for(var x in graph) {\n      const node = graph[x];\n      node.f = 0;\n      node.g = 0;\n      node.h = 0;\n      node.cost = 1.0;\n      node.visited = false;\n      node.closed = false;\n      node.parent = null;\n    }\n  }\n\n  static cleanUp (graph) {\n    for (let x = 0; x < graph.length; x++) {\n      const node = graph[x];\n      delete node.f;\n      delete node.g;\n      delete node.h;\n      delete node.cost;\n      delete node.visited;\n      delete node.closed;\n      delete node.parent;\n    }\n  }\n\n  static heap () {\n    return new BinaryHeap(function (node) {\n      return node.f;\n    });\n  }\n\n  static search (graph, start, end) {\n    this.init(graph);\n    //heuristic = heuristic || astar.manhattan;\n\n\n    const openHeap = this.heap();\n\n    openHeap.push(start);\n\n    while (openHeap.size() > 0) {\n\n      // Grab the lowest f(x) to process next.  Heap keeps this sorted for us.\n      const currentNode = openHeap.pop();\n\n      // End case -- result has been found, return the traced path.\n      if (currentNode === end) {\n        let curr = currentNode;\n        const ret = [];\n        while (curr.parent) {\n          ret.push(curr);\n          curr = curr.parent;\n        }\n        this.cleanUp(ret);\n        return ret.reverse();\n      }\n\n      // Normal case -- move currentNode from open to closed, process each of its neighbours.\n      currentNode.closed = true;\n\n      // Find all neighbours for the current node. Optionally find diagonal neighbours as well (false by default).\n      const neighbours = this.neighbours(graph, currentNode);\n\n      for (let i = 0, il = neighbours.length; i < il; i++) {\n        const neighbour = neighbours[i];\n\n        if (neighbour.closed) {\n          // Not a valid node to process, skip to next neighbour.\n          continue;\n        }\n\n        // The g score is the shortest distance from start to current node.\n        // We need to check if the path we have arrived at this neighbour is the shortest one we have seen yet.\n        const gScore = currentNode.g + neighbour.cost;\n        const beenVisited = neighbour.visited;\n\n        if (!beenVisited || gScore < neighbour.g) {\n\n          // Found an optimal (so far) path to this node.  Take score for node to see how good it is.\n          neighbour.visited = true;\n          neighbour.parent = currentNode;\n          if (!neighbour.centroid || !end.centroid) throw new Error('Unexpected state');\n          neighbour.h = neighbour.h || this.heuristic(neighbour.centroid, end.centroid);\n          neighbour.g = gScore;\n          neighbour.f = neighbour.g + neighbour.h;\n\n          if (!beenVisited) {\n            // Pushing to heap will put it in proper place based on the 'f' value.\n            openHeap.push(neighbour);\n          } else {\n            // Already seen the node, but since it has been rescored we need to reorder it in the heap\n            openHeap.rescoreElement(neighbour);\n          }\n        }\n      }\n    }\n\n    // No result was found - empty array signifies failure to find path.\n    return [];\n  }\n\n  static heuristic (pos1, pos2) {\n    return Utils.distanceToSquared(pos1, pos2);\n  }\n\n  static neighbours (graph, node) {\n    const ret = [];\n\n    for (let e = 0; e < node.neighbours.length; e++) {\n      ret.push(graph[node.neighbours[e]]);\n    }\n\n    return ret;\n  }\n}\n\nexport { AStar };\n","import {\n  BoxGeometry,\n  SphereGeometry,\n  BufferAttribute,\n  BufferGeometry,\n  Line,\n  LineBasicMaterial,\n  Mesh,\n  MeshBasicMaterial,\n  Object3D,\n  Vector3,\n} from 'three';\n\nconst colors = {\n  PLAYER: 0xEE836F,\n  TARGET: 0xDCCB18,\n  PATH: 0x00A3AF,\n  WAYPOINT: 0x00A3AF,\n  CLAMPED_STEP: 0xDCD3B2,\n  CLOSEST_NODE: 0x43676B,\n};\n\nconst OFFSET = 0.2;\n\n/**\n * Helper for debugging pathfinding behavior.\n */\nclass PathfindingHelper extends Object3D {\n  constructor () {\n    super();\n\n    this._playerMarker = new Mesh(\n      new SphereGeometry( 0.25, 32, 32 ),\n      new MeshBasicMaterial( { color: colors.PLAYER } )\n    );\n\n    this._targetMarker = new Mesh(\n      new BoxGeometry( 0.3, 0.3, 0.3 ),\n      new MeshBasicMaterial( { color: colors.TARGET } )\n    );\n\n\n    this._nodeMarker = new Mesh(\n      new BoxGeometry( 0.1, 0.8, 0.1 ),\n      new MeshBasicMaterial( { color: colors.CLOSEST_NODE } )\n    );\n\n\n    this._stepMarker = new Mesh(\n      new BoxGeometry( 0.1, 1, 0.1 ),\n      new MeshBasicMaterial( { color: colors.CLAMPED_STEP } )\n    );\n\n    this._pathMarker = new Object3D();\n\n    this._pathLineMaterial = new LineBasicMaterial( { color: colors.PATH, linewidth: 2 } ) ;\n    this._pathPointMaterial = new MeshBasicMaterial( { color: colors.WAYPOINT } );\n    this._pathPointGeometry = new SphereGeometry( 0.08 );\n\n    this._markers = [\n      this._playerMarker,\n      this._targetMarker,\n      this._nodeMarker,\n      this._stepMarker,\n      this._pathMarker,\n    ];\n\n    this._markers.forEach( ( marker ) => {\n\n      marker.visible = false;\n\n      this.add( marker );\n\n    } );\n\n  }\n\n  /**\n   * @param {Array<Vector3>} path\n   * @return {this}\n   */\n  setPath ( path ) {\n\n    while ( this._pathMarker.children.length ) {\n\n      this._pathMarker.children[ 0 ].visible = false;\n      this._pathMarker.remove( this._pathMarker.children[ 0 ] );\n\n    }\n\n    path = [ this._playerMarker.position ].concat( path );\n\n    // Draw debug lines\n    const geometry = new BufferGeometry();\n    geometry.setAttribute('position', new BufferAttribute(new Float32Array(path.length * 3), 3));\n    for (let i = 0; i < path.length; i++) {\n      geometry.attributes.position.setXYZ(i, path[ i ].x, path[ i ].y + OFFSET, path[ i ].z);\n    }\n    this._pathMarker.add( new Line( geometry, this._pathLineMaterial ) );\n\n    for ( let i = 0; i < path.length - 1; i++ ) {\n\n      const node = new Mesh( this._pathPointGeometry, this._pathPointMaterial );\n      node.position.copy( path[ i ] );\n      node.position.y += OFFSET;\n      this._pathMarker.add( node );\n\n    }\n\n    this._pathMarker.visible = true;\n\n    return this;\n\n  }\n\n  /**\n   * @param {Vector3} position\n   * @return {this}\n   */\n  setPlayerPosition( position ) {\n\n    this._playerMarker.position.copy( position );\n    this._playerMarker.visible = true;\n    return this;\n\n  }\n\n  /**\n   * @param {Vector3} position\n   * @return {this}\n   */\n  setTargetPosition( position ) {\n\n    this._targetMarker.position.copy( position );\n    this._targetMarker.visible = true;\n    return this;\n\n  }\n\n  /**\n   * @param {Vector3} position\n   * @return {this}\n   */\n  setNodePosition( position ) {\n\n    this._nodeMarker.position.copy( position );\n    this._nodeMarker.visible = true;\n    return this;\n\n  }\n\n  /**\n   * @param {Vector3} position\n   * @return {this}\n   */\n  setStepPosition( position ) {\n\n    this._stepMarker.position.copy( position );\n    this._stepMarker.visible = true;\n    return this;\n\n  }\n\n  /**\n   * Hides all markers.\n   * @return {this}\n   */\n  reset () {\n\n    while ( this._pathMarker.children.length ) {\n\n      this._pathMarker.children[ 0 ].visible = false;\n      this._pathMarker.remove( this._pathMarker.children[ 0 ] );\n\n    }\n\n    this._markers.forEach( ( marker ) => {\n\n      marker.visible = false;\n\n    } );\n\n    return this;\n\n  }\n\n}\n\nexport { PathfindingHelper };\n"],"mappings":";AAEA,MAAMA,CAAA;EAEc,OAAAC,YAAEC,CAAA,EAAOC,CAAA;IACzB,MAAMC,CAAA,GAASC,IAAA,CAAKC,GAAA,CAAI,IAAIH,CAAA;IAC5B,OAAOE,IAAA,CAAKE,KAAA,CAAML,CAAA,GAAQE,CAAA,IAAUA,CACrC;EAAA;EAEY,OAAAI,OAAEN,CAAA;IACb,OAAOA,CAAA,CAAKG,IAAA,CAAKI,KAAA,CAAMJ,IAAA,CAAKK,MAAA,KAAWR,CAAA,CAAKS,MAAA,EAC7C;EAAA;EAEuB,OAAAC,kBAAEV,CAAA,EAAGC,CAAA;IAE3B,IAAIC,CAAA,GAAKF,CAAA,CAAEW,CAAA,GAAIV,CAAA,CAAEU,CAAA;MACbC,CAAA,GAAKZ,CAAA,CAAEa,CAAA,GAAIZ,CAAA,CAAEY,CAAA;MACbC,CAAA,GAAKd,CAAA,CAAEe,CAAA,GAAId,CAAA,CAAEc,CAAA;IAEjB,OAAOb,CAAA,GAAKA,CAAA,GAAKU,CAAA,GAAKA,CAAA,GAAKE,CAAA,GAAKA,CAEjC;EAAA;EAImB,OAAAE,cAAEhB,CAAA,EAAMC,CAAA;IAC1B,KAAK,IAAIC,CAAA,IAAI,GAAOU,CAAA,IAAK,GAAGE,CAAA,GAAId,CAAA,CAAKS,MAAA,EAAQQ,CAAA,GAAIH,CAAA,GAAI,KAAKF,CAAA,GAAIE,CAAA,EAAGG,CAAA,GAAIL,CAAA,GACjEZ,CAAA,CAAKY,CAAA,EAAGG,CAAA,IAAKd,CAAA,CAAGc,CAAA,IAAKd,CAAA,CAAGc,CAAA,GAAIf,CAAA,CAAKiB,CAAA,EAAGF,CAAA,IAAOf,CAAA,CAAKiB,CAAA,EAAGF,CAAA,IAAKd,CAAA,CAAGc,CAAA,IAAKd,CAAA,CAAGc,CAAA,GAAIf,CAAA,CAAKY,CAAA,EAAGG,CAAA,KAAQd,CAAA,CAAGU,CAAA,IAAKX,CAAA,CAAKiB,CAAA,EAAGN,CAAA,GAAIX,CAAA,CAAKY,CAAA,EAAGD,CAAA,KAAMV,CAAA,CAAGc,CAAA,GAAIf,CAAA,CAAKY,CAAA,EAAGG,CAAA,KAAMf,CAAA,CAAKiB,CAAA,EAAGF,CAAA,GAAIf,CAAA,CAAKY,CAAA,EAAGG,CAAA,IAAKf,CAAA,CAAKY,CAAA,EAAGD,CAAA,KAAOT,CAAA,IAAKA,CAAA;IAC/L,OAAOA,CACR;EAAA;EAEuB,OAAAgB,kBAAElB,CAAA,EAAQC,CAAA,EAASC,CAAA;IAKzC,IAAIU,CAAA,GAAc;MACdE,CAAA,IAAgB;MAEhBG,CAAA,GAAkB;IAQtB,OANAhB,CAAA,CAAQkB,SAAA,CAAUC,OAAA,CAASpB,CAAA;MACzBY,CAAA,GAAcT,IAAA,CAAKkB,GAAA,CAAInB,CAAA,CAASF,CAAA,EAAKa,CAAA,EAAGD,CAAA,GACxCE,CAAA,GAAeX,IAAA,CAAKmB,GAAA,CAAIpB,CAAA,CAASF,CAAA,EAAKa,CAAA,EAAGC,CAAA,GACzCG,CAAA,CAAgBM,IAAA,CAAKrB,CAAA,CAASF,CAAA;IAAA,OAG5BA,CAAA,CAAOa,CAAA,GAAIC,CAAA,GAAe,MAAOd,CAAA,CAAOa,CAAA,GAAID,CAAA,GAAc,MAC5D,KAAKI,aAAA,CAAcC,CAAA,EAAiBjB,CAAA,EAIvC;EAAA;EAEc,OAAAwB,SAAExB,CAAA,EAAGC,CAAA,EAAGC,CAAA;IAKrB,QAFSA,CAAA,CAAES,CAAA,GAAIX,CAAA,CAAEW,CAAA,KADRV,CAAA,CAAEc,CAAA,GAAIf,CAAA,CAAEe,CAAA,KADRd,CAAA,CAAEU,CAAA,GAAIX,CAAA,CAAEW,CAAA,KAGRT,CAAA,CAAEa,CAAA,GAAIf,CAAA,CAAEe,CAAA,CAElB;EAAA;EAEY,OAAAU,OAAEzB,CAAA,EAAGC,CAAA;IAChB,YAAYS,iBAAA,CAAkBV,CAAA,EAAGC,CAAA,IAAK,IACvC;EAAA;EAUmB,OAAAyB,cAAExB,CAAA,EAAsB;IAAA,IAAZU,CAAA,GAAAe,SAAA,CAAAlB,MAAA,QAAAkB,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAY;IAE1Cf,CAAA,GAAYT,IAAA,CAAKmB,GAAA,CAAKV,CAAA,EAAWiB,MAAA,CAAOC,OAAA;IAmBxC,KAfA,IAAIhB,CAAA,GAAc,IACdG,CAAA,GAAUf,CAAA,CAAS6B,QAAA,IACnBC,CAAA,GAAY9B,CAAA,CAAS+B,YAAA,CAAc,aACnCC,CAAA,GAAcjB,CAAA,GAAUA,CAAA,CAAQkB,KAAA,GAAQH,CAAA,CAAUG,KAAA,EAGlDC,CAAA,GAAY,GAEZC,CAAA,GAAa,IACbC,CAAA,GAAe,IAGfC,CAAA,GAAepC,IAAA,CAAKqC,KAAA,CAAO,IAAI5B,CAAA,GAC/Bd,CAAA,GAAkBK,IAAA,CAAKC,GAAA,CAAK,IAAImC,CAAA,GAE1BE,CAAA,GAAI,GAAGA,CAAA,GAAIP,CAAA,EAAaO,CAAA,IAAO;MAEvC,IAAIC,CAAA,GAAQzB,CAAA,GAAUA,CAAA,CAAQ0B,IAAA,CAAMF,CAAA,IAAMA,CAAA;QAGtCG,CAAA,GAAO;MAGXA,CAAA,OAAkBZ,CAAA,CAAUW,IAAA,CAAMD,CAAA,IAAU5C,CAAA,IAAnC,KACT8C,CAAA,OAAkBZ,CAAA,CAAUa,IAAA,CAAMH,CAAA,IAAU5C,CAAA,IAAnC,MACT8C,CAAA,OAAkBZ,CAAA,CAAUc,IAAA,CAAMJ,CAAA,IAAU5C,CAAA,IAAnC,QAIIgB,CAAA,GAEXuB,CAAA,CAAWd,IAAA,CAAMT,CAAA,CAAa8B,CAAA,MAI9BN,CAAA,CAAaf,IAAA,CAAMS,CAAA,CAAUW,IAAA,CAAMD,CAAA,IACnCJ,CAAA,CAAaf,IAAA,CAAMS,CAAA,CAAUa,IAAA,CAAMH,CAAA,IACnCJ,CAAA,CAAaf,IAAA,CAAMS,CAAA,CAAUc,IAAA,CAAMJ,CAAA,IAEnC5B,CAAA,CAAa8B,CAAA,IAASR,CAAA,EACtBC,CAAA,CAAWd,IAAA,CAAMa,CAAA,GACjBA,CAAA,GAIH;IAAA;IAID,MAAMW,CAAA,GAAoB,IAAI/C,CAAA,CAC5B,IAAIgD,YAAA,CAAcV,CAAA,GAClBN,CAAA,CAAUiB,QAAA,EACVjB,CAAA,CAAUkB,UAAA;MAGNC,CAAA,GAAS,IAAIlD,CAAA;IAInB,OAHAkD,CAAA,CAAOC,YAAA,CAAc,YAAYL,CAAA,GACjCI,CAAA,CAAOE,QAAA,CAAUhB,CAAA,GAEVc,CAER;EAAA;AAAA;ACxIH,MAAMV,CAAA;EACJa,YAAatD,CAAA;IACX,KAAKuD,OAAA,GAAU,IACf,KAAKC,aAAA,GAAgBxD,CACtB;EAAA;EAEDuB,KAAMvB,CAAA;IAEJ,KAAKuD,OAAA,CAAQhC,IAAA,CAAKvB,CAAA,GAGlB,KAAKyD,QAAA,CAAS,KAAKF,OAAA,CAAQ9C,MAAA,GAAS,EACrC;EAAA;EAEDiD,IAAA;IAEE,MAAM1D,CAAA,GAAS,KAAKuD,OAAA,CAAQ;MAEtBtD,CAAA,GAAM,KAAKsD,OAAA,CAAQG,GAAA;IAOzB,OAJI,KAAKH,OAAA,CAAQ9C,MAAA,GAAS,MACxB,KAAK8C,OAAA,CAAQ,KAAKtD,CAAA,EAClB,KAAK0D,QAAA,CAAS,KAET3D,CACR;EAAA;EAED4D,OAAQ5D,CAAA;IACN,MAAMC,CAAA,GAAI,KAAKsD,OAAA,CAAQM,OAAA,CAAQ7D,CAAA;MAIzBE,CAAA,GAAM,KAAKqD,OAAA,CAAQG,GAAA;IAErBzD,CAAA,KAAM,KAAKsD,OAAA,CAAQ9C,MAAA,GAAS,MAC9B,KAAK8C,OAAA,CAAQtD,CAAA,IAAKC,CAAA,EAEd,KAAKsD,aAAA,CAActD,CAAA,IAAO,KAAKsD,aAAA,CAAcxD,CAAA,IAC/C,KAAKyD,QAAA,CAASxD,CAAA,IAEd,KAAK0D,QAAA,CAAS1D,CAAA,EAGnB;EAAA;EAED6D,KAAA;IACE,YAAYP,OAAA,CAAQ9C,MACrB;EAAA;EAEDsD,eAAgB/D,CAAA;IACd,KAAKyD,QAAA,CAAS,KAAKF,OAAA,CAAQM,OAAA,CAAQ7D,CAAA,EACpC;EAAA;EAEDyD,SAAUzD,CAAA;IAER,MAAMC,CAAA,GAAU,KAAKsD,OAAA,CAAQvD,CAAA;IAG7B,OAAOA,CAAA,GAAI,IAAG;MAEZ,MAAME,CAAA,IAAYF,CAAA,GAAI,KAAM,KAAK;QAC3BY,CAAA,GAAS,KAAK2C,OAAA,CAAQrD,CAAA;MAE5B,MAAI,KAAKsD,aAAA,CAAcvD,CAAA,IAAW,KAAKuD,aAAA,CAAc5C,CAAA,IAQnD;MANA,KAAK2C,OAAA,CAAQrD,CAAA,IAAWD,CAAA,EACxB,KAAKsD,OAAA,CAAQvD,CAAA,IAAKY,CAAA,EAElBZ,CAAA,GAAIE,CAKP;IAAA;EACF;EAEDyD,SAAU3D,CAAA;IAER,MAAMC,CAAA,GAAS,KAAKsD,OAAA,CAAQ9C,MAAA;MAC1BP,CAAA,GAAU,KAAKqD,OAAA,CAAQvD,CAAA;MACvBY,CAAA,GAAY,KAAK4C,aAAA,CAActD,CAAA;IAEjC,SAAa;MAEX,MAAMY,CAAA,GAAWd,CAAA,GAAI,KAAM;QACzBiB,CAAA,GAAUH,CAAA,GAAU;MAGtB,IACIkB,CAAA;QADAE,CAAA,GAAO;MAwBX,IArBIjB,CAAA,GAAUhB,CAAA,KAGZ+B,CAAA,GAAc,KAAKwB,aAAA,CADJ,KAAKD,OAAA,CAAQtC,CAAA,IAIxBe,CAAA,GAAcpB,CAAA,KAChBsB,CAAA,GAAOjB,CAAA,IAKPH,CAAA,GAAUb,CAAA,IAEI,KAAKuD,aAAA,CADN,KAAKD,OAAA,CAAQzC,CAAA,MAEA,SAAToB,CAAA,GAAgBtB,CAAA,GAAYoB,CAAA,MAC7CE,CAAA,GAAOpB,CAAA,GAKE,SAAToB,CAAA,EAQF;MAPA,KAAKqB,OAAA,CAAQvD,CAAA,IAAK,KAAKuD,OAAA,CAAQrB,CAAA,GAC/B,KAAKqB,OAAA,CAAQrB,CAAA,IAAQhC,CAAA,EACrBF,CAAA,GAAIkC,CAOP;IAAA;EACF;AAAA;AC/HH,MAAMQ,CAAA;EACJY,YAAA;IACE,KAAKU,OAAA,GAAU,EAChB;EAAA;EAEDzC,KAAMvB,CAAA,EAAIC,CAAA;IAAA,KACG,MAAPA,CAAA,KAAkBA,CAAA,GAAKD,CAAA,GAC3B,KAAKgE,OAAA,CAAQzC,IAAA,CAAK;MAChB0C,IAAA,EAAMjE,CAAA;MACNkE,KAAA,EAAOjE;IAAA,EAEV;EAAA;EAEDkE,WAAA;IACE,MAAMnE,CAAA,GAAU,KAAKgE,OAAA;MACf/D,CAAA,GAAM;IAEZ,IAAIC,CAAA;MAAYU,CAAA;MAAYE,CAAA;MACxBG,CAAA,GAAY;MACde,CAAA,GAAY;MACZE,CAAA,GAAa;IAEfhC,CAAA,GAAaF,CAAA,CAAQ,GAAGiE,IAAA,EACxBrD,CAAA,GAAaZ,CAAA,CAAQ,GAAGiE,IAAA,EACxBnD,CAAA,GAAcd,CAAA,CAAQ,GAAGkE,KAAA,EAGzBjE,CAAA,CAAIsB,IAAA,CAAKrB,CAAA;IAET,KAAK,IAAIkC,CAAA,GAAI,GAAGA,CAAA,GAAIpC,CAAA,CAAQS,MAAA,EAAQ2B,CAAA,IAAK;MACvC,MAAMC,CAAA,GAAOrC,CAAA,CAAQoC,CAAA,EAAG6B,IAAA;QAClB3B,CAAA,GAAQtC,CAAA,CAAQoC,CAAA,EAAG8B,KAAA;MAGzB,IAAIpE,CAAA,CAAM0B,QAAA,CAAStB,CAAA,EAAYY,CAAA,EAAawB,CAAA,KAAU,GAAK;QACzD,MAAIxC,CAAA,CAAM2B,MAAA,CAAOvB,CAAA,EAAYY,CAAA,KAAgBhB,CAAA,CAAM0B,QAAA,CAAStB,CAAA,EAAYU,CAAA,EAAY0B,CAAA,IAAS,IAItF;UAELrC,CAAA,CAAIsB,IAAA,CAAKX,CAAA,GAETV,CAAA,GAAaU,CAAA,EACbK,CAAA,GAAYe,CAAA,EAEZpB,CAAA,GAAaV,CAAA,EACbY,CAAA,GAAcZ,CAAA,EACd8B,CAAA,GAAYf,CAAA,EACZiB,CAAA,GAAajB,CAAA,EAEbmB,CAAA,GAAInB,CAAA;UACJ;QACD;QAhBCH,CAAA,GAAcwB,CAAA,EACdJ,CAAA,GAAaE,CAgBhB;MAAA;MAGD,IAAItC,CAAA,CAAM0B,QAAA,CAAStB,CAAA,EAAYU,CAAA,EAAYyB,CAAA,KAAS,GAAK;QACvD,MAAIvC,CAAA,CAAM2B,MAAA,CAAOvB,CAAA,EAAYU,CAAA,KAAed,CAAA,CAAM0B,QAAA,CAAStB,CAAA,EAAYY,CAAA,EAAauB,CAAA,IAAQ,IAIrF;UAELpC,CAAA,CAAIsB,IAAA,CAAKT,CAAA,GAETZ,CAAA,GAAaY,CAAA,EACbG,CAAA,GAAYiB,CAAA,EAEZtB,CAAA,GAAaV,CAAA,EACbY,CAAA,GAAcZ,CAAA,EACd8B,CAAA,GAAYf,CAAA,EACZiB,CAAA,GAAajB,CAAA,EAEbmB,CAAA,GAAInB,CAAA;UACJ;QACD;QAhBCL,CAAA,GAAayB,CAAA,EACbL,CAAA,GAAYI,CAgBf;MAAA;IACF;IAQD,OANoB,MAAfnC,CAAA,CAAIQ,MAAA,IAAmBX,CAAA,CAAM2B,MAAA,CAAOxB,CAAA,CAAIA,CAAA,CAAIQ,MAAA,GAAS,IAAIT,CAAA,CAAQA,CAAA,CAAQS,MAAA,GAAS,GAAGwD,IAAA,KAExFhE,CAAA,CAAIsB,IAAA,CAAKvB,CAAA,CAAQA,CAAA,CAAQS,MAAA,GAAS,GAAGwD,IAAA,GAGvC,KAAKG,IAAA,GAAOnE,CAAA,EACLA,CACR;EAAA;AAAA;AC3EH,MAAM2C,CAAA;EACLU,YAAA;IACC,KAAKe,KAAA,GAAQ,EACb;EAAA;EAQgB,OAAAC,WAAEtE,CAAA,EAAsB;IAAA,IAAZC,CAAA,GAAA0B,SAAA,CAAAlB,MAAA,QAAAkB,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAY;IACxC,OCtBF;MAOkB,OAAA4C,UAAEvE,CAAA,EAAUC,CAAA;QAE1B,MAAMW,CAAA,GAAU,KAAK4D,oBAAA,CAAqBxE,CAAA,EAAUC,CAAA;UAE9Ca,CAAA,GAAO;QAEbF,CAAA,CAAQ6D,QAAA,CAASrD,OAAA,CAASpB,CAAA;UACxBA,CAAA,CAAEW,CAAA,GAAIb,CAAA,CAAMC,WAAA,CAAYC,CAAA,CAAEW,CAAA,EAAG,IAC7BX,CAAA,CAAEa,CAAA,GAAIf,CAAA,CAAMC,WAAA,CAAYC,CAAA,CAAEa,CAAA,EAAG,IAC7Bb,CAAA,CAAEe,CAAA,GAAIjB,CAAA,CAAMC,WAAA,CAAYC,CAAA,CAAEe,CAAA,EAAG;QAAA,IAG/BD,CAAA,CAAK2D,QAAA,GAAW7D,CAAA,CAAQ6D,QAAA;QAExB,MAAMxD,CAAA,GAAS,KAAKyD,mBAAA,CAAoB9D,CAAA;QA0CxC,OArCAE,CAAA,CAAK6D,MAAA,GAAS,IAAIC,KAAA,CAAM3D,CAAA,CAAOR,MAAA,GAC/BQ,CAAA,CAAOG,OAAA,CAAQ,CAACpB,CAAA,EAAOC,CAAA;UAErB,MAAMW,CAAA,GAAiB,IAAIiE,GAAA;UAC3B7E,CAAA,CAAMoB,OAAA,CAAQ,CAACpB,CAAA,EAAMC,CAAA;YAAgBW,CAAA,CAAekE,GAAA,CAAI9E,CAAA,EAAMC,CAAA;UAAA;UAE9D,MAAMgB,CAAA,GAAW,IAAI2D,KAAA,CAAM5E,CAAA,CAAMS,MAAA;UACjCT,CAAA,CAAMoB,OAAA,CAAQ,CAACpB,CAAA,EAAMC,CAAA;YAEnB,MAAM+B,CAAA,GAAmB;YACzBhC,CAAA,CAAK+E,UAAA,CAAW3D,OAAA,CAASpB,CAAA,IAAMgC,CAAA,CAAiBT,IAAA,CAAKX,CAAA,CAAeoE,GAAA,CAAIhF,CAAA;YAGxE,MAAMkC,CAAA,GAAU;YAChBlC,CAAA,CAAK+E,UAAA,CAAW3D,OAAA,CAASnB,CAAA,IAAMiC,CAAA,CAAQX,IAAA,CAAK,KAAK0D,yBAAA,CAA0BjF,CAAA,EAAMC,CAAA;YAEjF,MAAMmC,CAAA,GAAW,IAAIlC,CAAA,CAAS,GAAG,GAAG;YACpCkC,CAAA,CAAS8C,GAAA,CAAKpE,CAAA,CAAK2D,QAAA,CAAUzE,CAAA,CAAKmB,SAAA,CAAU,MAC5CiB,CAAA,CAAS8C,GAAA,CAAKpE,CAAA,CAAK2D,QAAA,CAAUzE,CAAA,CAAKmB,SAAA,CAAU,MAC5CiB,CAAA,CAAS8C,GAAA,CAAKpE,CAAA,CAAK2D,QAAA,CAAUzE,CAAA,CAAKmB,SAAA,CAAU,MAC5CiB,CAAA,CAAS+C,YAAA,CAAc,IACvB/C,CAAA,CAASzB,CAAA,GAAIb,CAAA,CAAMC,WAAA,CAAYqC,CAAA,CAASzB,CAAA,EAAG,IAC3CyB,CAAA,CAASvB,CAAA,GAAIf,CAAA,CAAMC,WAAA,CAAYqC,CAAA,CAASvB,CAAA,EAAG,IAC3CuB,CAAA,CAASrB,CAAA,GAAIjB,CAAA,CAAMC,WAAA,CAAYqC,CAAA,CAASrB,CAAA,EAAG,IAE3CE,CAAA,CAAShB,CAAA,IAAa;cACpBmF,EAAA,EAAInF,CAAA;cACJ8E,UAAA,EAAY/C,CAAA;cACZb,SAAA,EAAWnB,CAAA,CAAKmB,SAAA;cAChBkE,QAAA,EAAUjD,CAAA;cACV4B,OAAA,EAAS9B;YAAA;UAAA,IAIbpB,CAAA,CAAK6D,MAAA,CAAO1E,CAAA,IAAcgB,CAAA;QAAA,IAGrBH,CACR;MAAA;MAO0B,OAAA0D,qBAAExE,CAAA,EAAUC,CAAA;QAErC,OADAD,CAAA,GAAWF,CAAA,CAAM4B,aAAA,CAAc1B,CAAA,EAAUC,CAAA,QAC7BqF,0BAAA,CAA2BtF,CAAA,CACxC;MAAA;MAMoB,OAAAuF,eAAEvF,CAAA;QACrB,IAAIC,CAAA,GAAY,IAAIuF,GAAA,CAAI,CAACxF,CAAA;QAEzB,OAAMC,CAAA,CAAU6D,IAAA,GAAO,IAAG;UACxB,MAAM5D,CAAA,GAAQD,CAAA;UACdA,CAAA,GAAY,IAAIuF,GAAA,IAEhBtF,CAAA,CAAMkB,OAAA,CAASlB,CAAA;YACbA,CAAA,CAAQuF,KAAA,GAAQzF,CAAA,CAAKyF,KAAA,EACrBvF,CAAA,CAAQ6E,UAAA,CAAW3D,OAAA,CAASpB,CAAA;cAAA,KACH,MAApBA,CAAA,CAAUyF,KAAA,IACXxF,CAAA,CAAUiF,GAAA,CAAIlF,CAAA,CACf;YAAA;UAAA,EAGN;QAAA;MACF;MAEyB,OAAA0E,oBAAE1E,CAAA;QAE1B,MAEMC,CAAA,GAAgB;QActB,OAhBiBD,CAAA,CAAe0F,QAAA,CAIvBtE,OAAA,CAASpB,CAAA;UAAA,KACM,MAAlBA,CAAA,CAAQyF,KAAA,GAEVxF,CAAA,CAAcD,CAAA,CAAQyF,KAAA,EAAOlE,IAAA,CAAKvB,CAAA,KAGlCA,CAAA,CAAQyF,KAAA,GAAQxF,CAAA,CAAcQ,MAAA,EAC9B,KAAK8E,cAAA,CAAevF,CAAA,GACpBC,CAAA,CAAcsB,IAAA,CAAK,CAACvB,CAAA,GACrB;QAAA,IAGIC,CACR;MAAA;MAE6B,OAAA0F,wBAAE3F,CAAA,EAASC,CAAA;QACvC,MAAMC,CAAA,GAAa,IAAIsF,GAAA;UAGjB5E,CAAA,GAASX,CAAA,CAAiBD,CAAA,CAAQmB,SAAA,CAAU;UAC5CL,CAAA,GAASb,CAAA,CAAiBD,CAAA,CAAQmB,SAAA,CAAU;QAkBlD,OApBelB,CAAA,CAAiBD,CAAA,CAAQmB,SAAA,CAAU,IAO3CC,OAAA,CAASnB,CAAA;UACVA,CAAA,KAAcD,CAAA,KACdY,CAAA,CAAOgF,QAAA,CAAS3F,CAAA,KAAca,CAAA,CAAO8E,QAAA,CAAS3F,CAAA,MAChDC,CAAA,CAAWgF,GAAA,CAAIjF,CAAA,CAChB;QAAA,IAEHW,CAAA,CAAOQ,OAAA,CAASnB,CAAA;UACVA,CAAA,KAAcD,CAAA,IACdc,CAAA,CAAO8E,QAAA,CAAS3F,CAAA,KAClBC,CAAA,CAAWgF,GAAA,CAAIjF,CAAA,CAChB;QAAA,IAGIC,CACR;MAAA;MAEgC,OAAAoF,2BAAEtF,CAAA;QAEjC,MAAMC,CAAA,GAAW;UACXW,CAAA,GAAW;UAEXE,CAAA,GAAWd,CAAA,CAAS6F,UAAA,CAAWC,QAAA;UAC/B7E,CAAA,GAAQjB,CAAA,CAAS+F,KAAA;UAQjB/D,CAAA,GAAmB;QAEzB,KAAK,IAAIhC,CAAA,GAAI,GAAGA,CAAA,GAAIc,CAAA,CAASqB,KAAA,EAAOnC,CAAA,IAClCY,CAAA,CAASW,IAAA,CAAK,IAAIrB,CAAA,GAAU8F,mBAAA,CAAoBlF,CAAA,EAAUd,CAAA,IAC1DgC,CAAA,CAAiBhC,CAAA,IAAK;QAIxB,KAAK,IAAIE,CAAA,GAAI,GAAGA,CAAA,GAAIF,CAAA,CAAS+F,KAAA,CAAM5D,KAAA,EAAOjC,CAAA,IAAK,GAAG;UAChD,MAAMF,CAAA,GAAIiB,CAAA,CAAM0B,IAAA,CAAKzC,CAAA;YACfU,CAAA,GAAIK,CAAA,CAAM0B,IAAA,CAAKzC,CAAA,GAAI;YACnBY,CAAA,GAAIG,CAAA,CAAM0B,IAAA,CAAKzC,CAAA,GAAI;YACnBgC,CAAA,GAAO;cAACf,SAAA,EAAW,CAACnB,CAAA,EAAGY,CAAA,EAAGE,CAAA;cAAIiE,UAAA,EAAY;YAAA;UAChD9E,CAAA,CAASsB,IAAA,CAAKW,CAAA,GACdF,CAAA,CAAiBhC,CAAA,EAAGuB,IAAA,CAAKW,CAAA,GACzBF,CAAA,CAAiBpB,CAAA,EAAGW,IAAA,CAAKW,CAAA,GACzBF,CAAA,CAAiBlB,CAAA,EAAGS,IAAA,CAAKW,CAAA,CAC1B;QAAA;QAOD,OAJAjC,CAAA,CAASmB,OAAA,CAASpB,CAAA;UAChBA,CAAA,CAAQ+E,UAAA,GAAa,KAAKY,uBAAA,CAAwB3F,CAAA,EAASgC,CAAA;QAAA,IAGtD;UACL0D,QAAA,EAAUzF,CAAA;UACVwE,QAAA,EAAU7D;QAAA,CAEb;MAAA;MAE+B,OAAAqE,0BAAEjF,CAAA,EAAGC,CAAA;QAEnC,MAAMC,CAAA,GAAQF,CAAA,CAAEmB,SAAA;UACVP,CAAA,GAAKV,CAAA,CAAM;UAAIY,CAAA,GAAKZ,CAAA,CAAM;UAAIe,CAAA,GAAKf,CAAA,CAAM;UAEzC8B,CAAA,GAAQ/B,CAAA,CAAEkB,SAAA;UACVe,CAAA,GAAUF,CAAA,CAAM4D,QAAA,CAAShF,CAAA;UACzBwB,CAAA,GAAUJ,CAAA,CAAM4D,QAAA,CAAS9E,CAAA;UACzBuB,CAAA,GAAUL,CAAA,CAAM4D,QAAA,CAAS3E,CAAA;QAK/B,OAAIiB,CAAA,IAAWE,CAAA,IAAWC,CAAA,GACjBuC,KAAA,CAAMqB,IAAA,CAAK/F,CAAA,IACTgC,CAAA,IAAWE,CAAA,GACb,CAACxB,CAAA,EAAIE,CAAA,IACHsB,CAAA,IAAWC,CAAA,GACb,CAACvB,CAAA,EAAIG,CAAA,IACHiB,CAAA,IAAWG,CAAA,GACb,CAACpB,CAAA,EAAIL,CAAA,KAEZsF,OAAA,CAAQC,IAAA,CAAK,yFACN,GAEV;MAAA;IAAA,EDhMc5B,SAAA,CAAUvE,CAAA,EAAUC,CAAA,CACnC;EAAA;EAODmG,YAAapG,CAAA,EAAQC,CAAA;IACpB,KAAKoE,KAAA,CAAMrE,CAAA,IAAUC,CACrB;EAAA;EAUDoG,cAAerG,CAAA,EAAQC,CAAA,EAASW,CAAA,EAAcE,CAAA;IAE7C,KAAK,KAAKuD,KAAA,CAAMrE,CAAA,GAAS,WAAWE,CAAA;IAEpCU,CAAA,GAAeA,CAAA,IAAgB,MAC/BE,CAAA,GAAYA,CAAA,IAAa;IAEzB,MAAMG,CAAA,GAAa;IAanB,OAZiB,KAAKoD,KAAA,CAAMrE,CAAA,EAAQ2E,MAAA,CAAO1E,CAAA,EAElCmB,OAAA,CAASpB,CAAA;MACbY,CAAA,IAAgBE,CAAA,GACfhB,CAAA,CAAMY,iBAAA,CAAkBE,CAAA,EAAcZ,CAAA,CAAEqF,QAAA,IAAYvE,CAAA,GAAYA,CAAA,IACnEG,CAAA,CAAWM,IAAA,CAAKvB,CAAA,CAAEqF,QAAA,IAGnBpE,CAAA,CAAWM,IAAA,CAAKvB,CAAA,CAAEqF,QAAA,CAClB;IAAA,IAGKvF,CAAA,CAAMQ,MAAA,CAAOW,CAAA,KAAe,IAAIf,CACvC,CADuC,CACvC;EAAA;EAUDoG,eAAgBtG,CAAA,EAAUC,CAAA,EAAQC,CAAA,EAAwB;IAAA,IAAfU,CAAA,GAAAe,SAAA,CAAAlB,MAAA,QAAAkB,SAAA,QAAAC,SAAA,GAAAD,SAAA,OAAe;IACzD,MACMb,CAAA,GAAW,KAAKuD,KAAA,CAAMpE,CAAA,EAAQwE,QAAA;IACpC,IAAIxD,CAAA,GAAc;MACde,CAAA,GAAkBuE,QAAA;IAWtB,OAdc,KAAKlC,KAAA,CAAMpE,CAAA,EAAQ0E,MAAA,CAAOzE,CAAA,EAKlCkB,OAAA,CAASnB,CAAA;MACd,MAAMC,CAAA,GAAWJ,CAAA,CAAMY,iBAAA,CAAkBT,CAAA,CAAKoF,QAAA,EAAUrF,CAAA;MACpDE,CAAA,GAAW8B,CAAA,MACRpB,CAAA,IAAgBd,CAAA,CAAMoB,iBAAA,CAAkBlB,CAAA,EAAUC,CAAA,EAAMa,CAAA,OAC9DG,CAAA,GAAchB,CAAA,EACd+B,CAAA,GAAkB9B,CAAA,CAClB;IAAA,IAGKe,CACP;EAAA;EAYDuF,SAAUxG,CAAA,EAAeC,CAAA,EAAgBW,CAAA,EAAQE,CAAA;IAChD,MAAMG,CAAA,GAAQ,KAAKoD,KAAA,CAAMzD,CAAA,EAAQ+D,MAAA,CAAO7D,CAAA;MAClCkB,CAAA,GAAW,KAAKqC,KAAA,CAAMzD,CAAA,EAAQ6D,QAAA;MAE9BvC,CAAA,GAAc,KAAKoE,cAAA,CAAetG,CAAA,EAAeY,CAAA,EAAQE,CAAA,GAAS;MAClEsB,CAAA,GAAe,KAAKkE,cAAA,CAAerG,CAAA,EAAgBW,CAAA,EAAQE,CAAA,GAAS;IAG1E,KAAKoB,CAAA,KAAgBE,CAAA,EACpB;IAGD,MAAMC,CAAA,GElHR;QACa,OAAAoE,KAAEzG,CAAA;UACX,KAAK,IAAIC,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAMS,MAAA,EAAQR,CAAA,IAAK;YAErC,MAAMC,CAAA,GAAOF,CAAA,CAAMC,CAAA;YACnBC,CAAA,CAAK0C,CAAA,GAAI,GACT1C,CAAA,CAAKwC,CAAA,GAAI,GACTxC,CAAA,CAAKgC,CAAA,GAAI,GACThC,CAAA,CAAKwG,IAAA,GAAO,GACZxG,CAAA,CAAKyG,OAAA,IAAU,GACfzG,CAAA,CAAK0G,MAAA,IAAS,GACd1G,CAAA,CAAK2G,MAAA,GAAS,IACf;UAAA;QACF;QAEa,OAAAC,QAAE9G,CAAA;UACd,KAAK,IAAIC,CAAA,GAAI,GAAGA,CAAA,GAAID,CAAA,CAAMS,MAAA,EAAQR,CAAA,IAAK;YACrC,MAAMC,CAAA,GAAOF,CAAA,CAAMC,CAAA;YAAA,OACZC,CAAA,CAAK0C,CAAA,SACL1C,CAAA,CAAKwC,CAAA,SACLxC,CAAA,CAAKgC,CAAA,SACLhC,CAAA,CAAKwG,IAAA,SACLxG,CAAA,CAAKyG,OAAA,SACLzG,CAAA,CAAK0G,MAAA,SACL1G,CAAA,CAAK2G,MACb;UAAA;QACF;QAEU,OAAAE,KAAA;UACT,WAAWtE,CAAA,CAAW,UAAUzC,CAAA;YAC9B,OAAOA,CAAA,CAAK4C,CACb;UAAA,EACF;QAAA;QAEY,OAAAoE,OAAEhH,CAAA,EAAOC,CAAA,EAAOC,CAAA;UAC3B,KAAKuG,IAAA,CAAKzG,CAAA;UAIV,MAAMY,CAAA,GAAW,KAAKmG,IAAA;UAItB,KAFAnG,CAAA,CAASW,IAAA,CAAKtB,CAAA,GAEPW,CAAA,CAASkD,IAAA,KAAS,IAAG;YAG1B,MAAM7D,CAAA,GAAcW,CAAA,CAAS8C,GAAA;YAG7B,IAAIzD,CAAA,KAAgBC,CAAA,EAAK;cACvB,IAAIF,CAAA,GAAOC,CAAA;cACX,MAAMC,CAAA,GAAM;cACZ,OAAOF,CAAA,CAAK6G,MAAA,GACV3G,CAAA,CAAIqB,IAAA,CAAKvB,CAAA,GACTA,CAAA,GAAOA,CAAA,CAAK6G,MAAA;cAGd,OADA,KAAKC,OAAA,CAAQ5G,CAAA,GACNA,CAAA,CAAI+G,OAAA,EACZ;YAAA;YAGDhH,CAAA,CAAY2G,MAAA,IAAS;YAGrB,MAAM9F,CAAA,GAAa,KAAKiE,UAAA,CAAW/E,CAAA,EAAOC,CAAA;YAE1C,KAAK,IAAID,CAAA,GAAI,GAAGiB,CAAA,GAAKH,CAAA,CAAWL,MAAA,EAAQT,CAAA,GAAIiB,CAAA,EAAIjB,CAAA,IAAK;cACnD,MAAMiB,CAAA,GAAYH,CAAA,CAAWd,CAAA;cAE7B,IAAIiB,CAAA,CAAU2F,MAAA,EAEZ;cAKF,MAAM5E,CAAA,GAAS/B,CAAA,CAAYyC,CAAA,GAAIzB,CAAA,CAAUyF,IAAA;gBACnCxE,CAAA,GAAcjB,CAAA,CAAU0F,OAAA;cAE9B,KAAKzE,CAAA,IAAeF,CAAA,GAASf,CAAA,CAAUyB,CAAA,EAAG;gBAKxC,IAFAzB,CAAA,CAAU0F,OAAA,IAAU,GACpB1F,CAAA,CAAU4F,MAAA,GAAS5G,CAAA,GACdgB,CAAA,CAAUoE,QAAA,KAAanF,CAAA,CAAImF,QAAA,EAAU,UAAU6B,KAAA,CAAM;gBAC1DjG,CAAA,CAAUiB,CAAA,GAAIjB,CAAA,CAAUiB,CAAA,IAAK,KAAKiF,SAAA,CAAUlG,CAAA,CAAUoE,QAAA,EAAUnF,CAAA,CAAImF,QAAA,GACpEpE,CAAA,CAAUyB,CAAA,GAAIV,CAAA,EACdf,CAAA,CAAU2B,CAAA,GAAI3B,CAAA,CAAUyB,CAAA,GAAIzB,CAAA,CAAUiB,CAAA,EAEjCA,CAAA,GAKHtB,CAAA,CAASmD,cAAA,CAAe9C,CAAA,IAHxBL,CAAA,CAASW,IAAA,CAAKN,CAAA,CAKjB;cAAA;YACF;UACF;UAGD,OAAO,EACR;QAAA;QAEe,OAAAkG,UAAEnH,CAAA,EAAMC,CAAA;UACtB,OAAOH,CAAA,CAAMY,iBAAA,CAAkBV,CAAA,EAAMC,CAAA,CACtC;QAAA;QAEgB,OAAA8E,WAAE/E,CAAA,EAAOC,CAAA;UACxB,MAAMC,CAAA,GAAM;UAEZ,KAAK,IAAIU,CAAA,GAAI,GAAGA,CAAA,GAAIX,CAAA,CAAK8E,UAAA,CAAWtE,MAAA,EAAQG,CAAA,IAC1CV,CAAA,CAAIqB,IAAA,CAAKvB,CAAA,CAAMC,CAAA,CAAK8E,UAAA,CAAWnE,CAAA;UAGjC,OAAOV,CACR;QAAA;MAAA,EFFmB8G,MAAA,CAAO/F,CAAA,EAAOiB,CAAA,EAAaE,CAAA;MAEzCE,CAAA,GAAkB,SAAA8E,CAAUpH,CAAA,EAAGC,CAAA;QACpC,KAAK,IAAIC,CAAA,GAAI,GAAGA,CAAA,GAAIF,CAAA,CAAE+E,UAAA,CAAWtE,MAAA,EAAQP,CAAA,IACxC,IAAIF,CAAA,CAAE+E,UAAA,CAAW7E,CAAA,MAAOD,CAAA,CAAEmF,EAAA,EACzB,OAAOpF,CAAA,CAAEgE,OAAA,CAAQ9D,CAAA,CAGnB;MAAA;MAGKqC,CAAA,GAAU,IAAIG,CAAA;IACpBH,CAAA,CAAQhB,IAAA,CAAKvB,CAAA;IACb,KAAK,IAAIA,CAAA,GAAI,GAAGA,CAAA,GAAIqC,CAAA,CAAM5B,MAAA,EAAQT,CAAA,IAAK;MACtC,MAAMC,CAAA,GAAUoC,CAAA,CAAMrC,CAAA;QAChBE,CAAA,GAAcmC,CAAA,CAAMrC,CAAA,GAAI;MAE9B,IAAIE,CAAA,EAAa;QAChB,MAAMF,CAAA,GAAUsC,CAAA,CAAgBrC,CAAA,EAASC,CAAA;QACzCqC,CAAA,CAAQhB,IAAA,CACPS,CAAA,CAAShC,CAAA,CAAQ,KACjBgC,CAAA,CAAShC,CAAA,CAAQ,IAElB;MAAA;IACD;IACDuC,CAAA,CAAQhB,IAAA,CAAKtB,CAAA,GACbsC,CAAA,CAAQ4B,UAAA;IAGR,MAAMvB,CAAA,GAAOL,CAAA,CAAQ6B,IAAA,CAAKiD,GAAA,CAAKrH,CAAA,IAAM,IAAIE,CAAA,CAAQF,CAAA,CAAEW,CAAA,EAAGX,CAAA,CAAEa,CAAA,EAAGb,CAAA,CAAEe,CAAA;IAE7D,OADA6B,CAAA,CAAK0E,KAAA,IACE1E,CACP;EAAA;AAAA;AASFA,CAAA,CAAY2E,SAAA,CAAUC,QAAA,GAAY;EACjC,MAAMxH,CAAA,GAAQ,IAAIY,CAAA;EAClB,iBAAiBX,CAAA,EAAQC,CAAA,EAAyB;IAAA,IAAfU,CAAA,GAAAe,SAAA,CAAAlB,MAAA,QAAAkB,SAAA,QAAAC,SAAA,GAAAD,SAAA,OAAe;IACjD,KAAK,KAAK0C,KAAA,CAAMpE,CAAA,GAAS;IAEzB,IAAIa,CAAA,GAAmB;MACnBG,CAAA,GAAWd,IAAA,CAAKC,GAAA,CAAI,IAAI;IAC5B,MAAM4B,CAAA,GAAO,KAAKqC,KAAA,CAAMpE,CAAA;IAExB,KAAK,IAAIA,CAAA,GAAI,GAAGA,CAAA,GAAI+B,CAAA,CAAK2C,MAAA,CAAOlE,MAAA,EAAQR,CAAA,IAAK;MAC5C,MAAMiC,CAAA,GAAQF,CAAA,CAAK2C,MAAA,CAAO1E,CAAA;MAC1B,KAAK,MAAMmC,CAAA,IAAQF,CAAA,EAAO;QACzB,IAAItB,CAAA,KACHZ,CAAA,CAAMyH,qBAAA,CACLzF,CAAA,CAAKyC,QAAA,CAASrC,CAAA,CAAKjB,SAAA,CAAU,KAC7Ba,CAAA,CAAKyC,QAAA,CAASrC,CAAA,CAAKjB,SAAA,CAAU,KAC7Ba,CAAA,CAAKyC,QAAA,CAASrC,CAAA,CAAKjB,SAAA,CAAU,MAE1BhB,IAAA,CAAKuH,GAAA,CAAI1H,CAAA,CAAM2H,eAAA,CAAgBzH,CAAA,KAAa,QAM5CJ,CAAA,CAAMkB,aAAA,CALI,CACZgB,CAAA,CAAKyC,QAAA,CAASrC,CAAA,CAAKjB,SAAA,CAAU,KAC7Ba,CAAA,CAAKyC,QAAA,CAASrC,CAAA,CAAKjB,SAAA,CAAU,KAC7Ba,CAAA,CAAKyC,QAAA,CAASrC,CAAA,CAAKjB,SAAA,CAAU,MAEDjB,CAAA,GAC5B,OAAOD,CAAA;QAIV,MAAMiC,CAAA,GAAmBpC,CAAA,CAAMY,iBAAA,CAAkB0B,CAAA,CAAKiD,QAAA,EAAUnF,CAAA;QAC5DgC,CAAA,GAAmBjB,CAAA,KACtBH,CAAA,GAAmBb,CAAA,EACnBgB,CAAA,GAAWiB,CAAA,CAEZ;MAAA;IACD;IAED,OAAOpB,CACP;EAAA,CACD;AAAA,CAvCiC,IAqDlC8B,CAAA,CAAY2E,SAAA,CAAUK,SAAA,GAAa;EAClC,MAAM5H,CAAA,GAAQ,IAAIE,CAAA;IACZD,CAAA,GAAQ,IAAIW,CAAA;IACZK,CAAA,GAAW,IAAIH,CAAA;IAEfkB,CAAA,GAAW,IAAI9B,CAAA;EAErB,IAAIgC,CAAA;IAEAE,CAAA;IADAC,CAAA,GAAe,IAAInC,CAAA;EAGvB,iBAAiBA,CAAA,EAAUU,CAAA,EAAQE,CAAA,EAAMwB,CAAA,EAAQC,CAAA,EAASzC,CAAA;IACzD,MAAM2C,CAAA,GAAW,KAAK4B,KAAA,CAAM/B,CAAA,EAAQmC,QAAA;MAC9B/B,CAAA,GAAQ,KAAK2B,KAAA,CAAM/B,CAAA,EAAQqC,MAAA,CAAOpC,CAAA;MAElCK,CAAA,GAAY,CAAC9B,CAAA;MACbiC,CAAA,GAAY;IAClBA,CAAA,CAAUjC,CAAA,CAAKsE,EAAA,IAAM,GAErBlD,CAAA,QAAc,GACdG,CAAA,CAAayC,GAAA,CAAI,GAAG,GAAG,IACvB1C,CAAA,GAAkBmE,QAAA,EAGlBtG,CAAA,CAAMwH,qBAAA,CACLhF,CAAA,CAAS3B,CAAA,CAAKK,SAAA,CAAU,KACxBsB,CAAA,CAAS3B,CAAA,CAAKK,SAAA,CAAU,KACxBsB,CAAA,CAAS3B,CAAA,CAAKK,SAAA,CAAU,MAEzBlB,CAAA,CAAM4H,YAAA,CAAajH,CAAA,EAAQZ,CAAA,GAC3BgC,CAAA,CAAS8F,IAAA,CAAK9H,CAAA;IAEd,KAAK,IAAIC,CAAA,GAAc2C,CAAA,CAAUc,GAAA,IAAOzD,CAAA,EAAaA,CAAA,GAAc2C,CAAA,CAAUc,GAAA,IAAO;MAEnFzC,CAAA,CAAS6D,GAAA,CACRrC,CAAA,CAASxC,CAAA,CAAYkB,SAAA,CAAU,KAC/BsB,CAAA,CAASxC,CAAA,CAAYkB,SAAA,CAAU,KAC/BsB,CAAA,CAASxC,CAAA,CAAYkB,SAAA,CAAU,MAGhCF,CAAA,CAAS8G,mBAAA,CAAoB/F,CAAA,EAAUhC,CAAA,GAEnCA,CAAA,CAAMU,iBAAA,CAAkBsB,CAAA,IAAYI,CAAA,KACvCF,CAAA,GAAcjC,CAAA,EACdoC,CAAA,CAAayF,IAAA,CAAK9H,CAAA,GAClBoC,CAAA,GAAkBpC,CAAA,CAAMU,iBAAA,CAAkBsB,CAAA;MAG3C,MAAM9B,CAAA,GAAQ6C,CAAA,CAAU9C,CAAA,CAAYmF,EAAA;MACpC,MAAIlF,CAAA,GAAQ,IAEZ,KAAK,IAAIF,CAAA,GAAI,GAAGA,CAAA,GAAIC,CAAA,CAAY8E,UAAA,CAAWtE,MAAA,EAAQT,CAAA,IAAK;QACvD,MAAMY,CAAA,GAAY8B,CAAA,CAAMzC,CAAA,CAAY8E,UAAA,CAAW/E,CAAA;QAC3CY,CAAA,CAAUwE,EAAA,IAAMrC,CAAA,KAEpBH,CAAA,CAAUrB,IAAA,CAAKX,CAAA,GACfmC,CAAA,CAAUnC,CAAA,CAAUwE,EAAA,IAAMlF,CAAA,GAAQ,EAClC;MAAA;IACD;IAGD,OADAJ,CAAA,CAAUgI,IAAA,CAAKzF,CAAA,GACRH,CACP;EAAA,CACD;AAAA,CA/DkC;AGxLnC,MAAMa,CAAA,SAA0B9B,CAAA;EAC9BqC,YAAA;IACE,SAEA,KAAK0E,aAAA,GAAgB,IAAIhG,CAAA,CACvB,IAAIE,CAAA,CAAgB,KAAM,IAAI,KAC9B,IAAIE,CAAA,CAAmB;MAAE6F,KAAA,EAnBrB;IAAA,KAsBN,KAAKC,aAAA,GAAgB,IAAIlG,CAAA,CACvB,IAAIK,CAAA,CAAa,IAAK,IAAK,KAC3B,IAAID,CAAA,CAAmB;MAAE6F,KAAA,EAvBrB;IAAA,KA2BN,KAAKE,WAAA,GAAc,IAAInG,CAAA,CACrB,IAAIK,CAAA,CAAa,IAAK,IAAK,KAC3B,IAAID,CAAA,CAAmB;MAAE6F,KAAA,EAzBf;IAAA,KA6BZ,KAAKG,WAAA,GAAc,IAAIpG,CAAA,CACrB,IAAIK,CAAA,CAAa,IAAK,GAAG,KACzB,IAAID,CAAA,CAAmB;MAAE6F,KAAA,EAhCf;IAAA,KAmCZ,KAAKI,WAAA,GAAc,IAAIpH,CAAA,IAEvB,KAAKqH,iBAAA,GAAoB,IAAIhG,CAAA,CAAmB;MAAE2F,KAAA,EAvC9C;MAuCkEM,SAAA,EAAW;IAAA,IACjF,KAAKC,kBAAA,GAAqB,IAAIpG,CAAA,CAAmB;MAAE6F,KAAA,EAvC3C;IAAA,IAwCR,KAAKQ,kBAAA,GAAqB,IAAIvG,CAAA,CAAgB,MAE9C,KAAKwG,QAAA,GAAW,CACd,KAAKV,aAAA,EACL,KAAKE,aAAA,EACL,KAAKC,WAAA,EACL,KAAKC,WAAA,EACL,KAAKC,WAAA,GAGP,KAAKK,QAAA,CAAStH,OAAA,CAAWpB,CAAA;MAEvBA,CAAA,CAAO2I,OAAA,IAAU,GAEjB,KAAKzD,GAAA,CAAKlF,CAAA;IAAA,EAIb;EAAA;EAMD4I,QAAU1I,CAAA;IAER,OAAQ,KAAKmI,WAAA,CAAYQ,QAAA,CAASpI,MAAA,GAEhC,KAAK4H,WAAA,CAAYQ,QAAA,CAAU,GAAIF,OAAA,IAAU,GACzC,KAAKN,WAAA,CAAYzE,MAAA,CAAQ,KAAKyE,WAAA,CAAYQ,QAAA,CAAU;IAItD3I,CAAA,GAAO,CAAE,KAAK8H,aAAA,CAAclC,QAAA,EAAWgD,MAAA,CAAQ5I,CAAA;IAG/C,MAAMU,CAAA,GAAW,IAAIX,CAAA;IACrBW,CAAA,CAASwC,YAAA,CAAa,YAAY,IAAIpD,CAAA,CAAgB,IAAIgD,YAAA,CAA2B,IAAd9C,CAAA,CAAKO,MAAA,GAAa;IACzF,KAAK,IAAIT,CAAA,GAAI,GAAGA,CAAA,GAAIE,CAAA,CAAKO,MAAA,EAAQT,CAAA,IAC/BY,CAAA,CAASiF,UAAA,CAAWC,QAAA,CAASiD,MAAA,CAAO/I,CAAA,EAAGE,CAAA,CAAMF,CAAA,EAAIW,CAAA,EAAGT,CAAA,CAAMF,CAAA,EAAIa,CAAA,GA1ErD,IA0EiEX,CAAA,CAAMF,CAAA,EAAIe,CAAA;IAEtF,KAAKsH,WAAA,CAAYnD,GAAA,CAAK,IAAI3C,CAAA,CAAM3B,CAAA,EAAU,KAAK0H,iBAAA;IAE/C,KAAM,IAAItI,CAAA,GAAI,GAAGA,CAAA,GAAIE,CAAA,CAAKO,MAAA,GAAS,GAAGT,CAAA,IAAM;MAE1C,MAAMC,CAAA,GAAO,IAAI+B,CAAA,CAAM,KAAKyG,kBAAA,EAAoB,KAAKD,kBAAA;MACrDvI,CAAA,CAAK6F,QAAA,CAASgC,IAAA,CAAM5H,CAAA,CAAMF,CAAA,IAC1BC,CAAA,CAAK6F,QAAA,CAASjF,CAAA,IAlFL,IAmFT,KAAKwH,WAAA,CAAYnD,GAAA,CAAKjF,CAAA,CAEvB;IAAA;IAID,OAFA,KAAKoI,WAAA,CAAYM,OAAA,IAAU,OAI5B;EAAA;EAMDK,kBAAmBhJ,CAAA;IAIjB,OAFA,KAAKgI,aAAA,CAAclC,QAAA,CAASgC,IAAA,CAAM9H,CAAA,GAClC,KAAKgI,aAAA,CAAcW,OAAA,IAAU,OAG9B;EAAA;EAMDM,kBAAmBjJ,CAAA;IAIjB,OAFA,KAAKkI,aAAA,CAAcpC,QAAA,CAASgC,IAAA,CAAM9H,CAAA,GAClC,KAAKkI,aAAA,CAAcS,OAAA,IAAU,OAG9B;EAAA;EAMDO,gBAAiBlJ,CAAA;IAIf,OAFA,KAAKmI,WAAA,CAAYrC,QAAA,CAASgC,IAAA,CAAM9H,CAAA,GAChC,KAAKmI,WAAA,CAAYQ,OAAA,IAAU,OAG5B;EAAA;EAMDQ,gBAAiBnJ,CAAA;IAIf,OAFA,KAAKoI,WAAA,CAAYtC,QAAA,CAASgC,IAAA,CAAM9H,CAAA,GAChC,KAAKoI,WAAA,CAAYO,OAAA,IAAU,OAG5B;EAAA;EAMDS,MAAA;IAEE,OAAQ,KAAKf,WAAA,CAAYQ,QAAA,CAASpI,MAAA,GAEhC,KAAK4H,WAAA,CAAYQ,QAAA,CAAU,GAAIF,OAAA,IAAU,GACzC,KAAKN,WAAA,CAAYzE,MAAA,CAAQ,KAAKyE,WAAA,CAAYQ,QAAA,CAAU;IAUtD,OANA,KAAKH,QAAA,CAAStH,OAAA,CAAWpB,CAAA;MAEvBA,CAAA,CAAO2I,OAAA,IAAU;IAAA,QAMpB;EAAA;AAAA;AAAA,SAAA/F,CAAA,IAAAyG,WAAA,EAAAtG,CAAA,IAAAuG,iBAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}